//
// SDEFSwiftCodeGenerator.swift
// SDEF
//
// Created by Rene Hexel on 1/06/2024.
// Copyright Â© 2024, 2025 Rene Hexel. All rights reserved.
//
import Foundation

/// A code generator that produces Swift Scripting Bridge code from parsed SDEF models.
///
/// The `SDEFSwiftCodeGenerator` transforms structured SDEF data into clean, type-safe Swift code
/// that provides interfaces for controlling scriptable macOS applications through the Scripting
/// Bridge framework. The generator handles proper Swift naming conventions, type mapping, and
/// protocol generation to create idiomatic Swift code from Apple Event definitions.
///
/// The generated code includes protocols for each scriptable class, enumerations for constant
/// values, type aliases for common Scripting Bridge types, and extension methods that provide
/// a complete Swift interface to the application's scripting capabilities.
public final class SDEFSwiftCodeGenerator {
    private let model: SDEFModel
    private let baseName: String
    private let shouldGenerateClassNamesEnum: Bool
    private let shouldGenerateStronglyTypedExtensions: Bool
    private let generatePrefixedTypealiases: Bool
    private let generateFlatTypealiases: Bool
    private let bundleIdentifier: String?
    private let isIncludedFile: Bool
    private let verbose: Bool
    private let debug: Bool
    private lazy var enumerationNames: Set<String> = {
        var names = Set<String>()
        for suite in model.suites {
            for enumeration in suite.enumerations {
                let enumName = enumeration.name.swiftClassName
                names.insert(enumName)
            }
        }
        return names
    }()

    /// Creates a new Swift code generator with the specified configuration.
    ///
    /// The generator uses the provided SDEF model to create comprehensive Swift code that
    /// mirrors the application's scripting interface. The basename parameter determines
    /// the prefix used for all generated types, ensuring they don't conflict with other
    /// generated code in the same project.
    ///
    /// - Parameters:
    ///   - model: The parsed SDEF model containing all scripting definitions
    ///   - basename: The prefix to use for all generated Swift types
    ///   - shouldGenerateClassNamesEnum: Whether to generate an enum containing all scripting class names
    ///   - shouldGenerateStronglyTypedExtensions: Whether to generate strongly typed accessor extensions
    ///   - generatePrefixedTypealiases: Whether to generate prefixed typealiases for backward compatibility
    ///   - generateFlatTypealiases: Whether to generate flat (unprefixed) typealiases
    ///   - bundleIdentifier: Optional bundle identifier for generating application() convenience function
    ///   - isIncludedFile: Whether this is an included file (skips foundation protocols)
    ///   - verbose: Whether to enable detailed logging during code generation
    ///   - debug: Whether to enable debug logging during code generation
    public init(model: SDEFModel, basename: String, shouldGenerateClassNamesEnum: Bool, shouldGenerateStronglyTypedExtensions: Bool, generatePrefixedTypealiases: Bool = false, generateFlatTypealiases: Bool = false, bundleIdentifier: String? = nil, isIncludedFile: Bool = false, verbose: Bool, debug: Bool = false) {
        self.model = model
        self.baseName = basename
        self.shouldGenerateClassNamesEnum = shouldGenerateClassNamesEnum
        self.shouldGenerateStronglyTypedExtensions = shouldGenerateStronglyTypedExtensions
        self.generatePrefixedTypealiases = generatePrefixedTypealiases
        self.generateFlatTypealiases = generateFlatTypealiases
        self.bundleIdentifier = bundleIdentifier
        self.isIncludedFile = isIncludedFile
        self.verbose = verbose
        self.debug = debug
    }

    /// Generates Swift source file code from the SDEF model.
    ///
    /// This method produces a complete Swift source file that includes all necessary imports,
    /// type definitions, protocols, and extensions needed to interact with the scriptable
    /// application. The generated code follows Swift best practices and provides type-safe
    /// interfaces that mirror the application's Apple Event scripting capabilities.
    ///
    /// The generation process creates several components: standard protocol definitions for
    /// generic scripting methods, enumerations for constant values, protocols for each
    /// scriptable class with their properties and methods, and extensions that conform
    /// Scripting Bridge types to these protocols.
    ///
    /// - Returns: A complete Swift source code string ready to be written to a file
    /// - Throws: `SDEFCodeGenerationError` if the model contains invalid or unsupported definitions
    public func generateCode() throws -> String {
        var code = """
        //
        // \(baseName).swift
        // Generated by sdef2swift
        //
        import Foundation
        import ScriptingBridge
        import AppKit

        """

        // Check if we have a Standard Suite in the SDEF
        let hasStandardSuite = model.suites.contains { $0.name.lowercased().contains("standard") }

        // Generate foundation protocols - always prefixed to avoid conflicts between different SDEF files
        code += """

        /// Protocol for ScriptingBridge Objects.
        ///
        /// This protocol defines the basic functionality for ScriptingBridge objects.
        @objc public protocol \(baseName)SBObjectProtocol: NSObjectProtocol {
            func get() -> Any!
        }
        extension SBObject: \(baseName)SBObjectProtocol {}

        /// Protocol for ScriptingBridge Applications.
        ///
        /// This protocol defines the basic functionality for ScriptingBridge applications
        """

        if !hasStandardSuite {
            code += ",\n        /// including standard Apple Event commands that most applications support."
        } else {
            code += "."
        }

        code += """

        @objc public protocol \(baseName)SBApplicationProtocol: \(baseName)SBObjectProtocol {
            // MARK: - Core Application Methods

            /// Activate the application, bringing it to the foreground.
            func activate()

            /// The application's delegate for handling Scripting Bridge events.
            var delegate: SBApplicationDelegate! { get set }

            /// Whether the application is currently running.
            var isRunning: Bool { get }
        """

        // Only add hard-coded standard commands if there's no Standard Suite in the SDEF
        if !hasStandardSuite {
            code += """

            // MARK: - Standard Suite Commands

            /// Open the specified object(s).
            /// - Parameters:
            ///   - objects: List of objects to open
            ///   - using: The application file to open the object with (optional)
            ///   - withProperties: Initial values for properties (optional)
            @objc optional func open(_ objects: Any!, using: Any?, withProperties: [String: Any]?)

            /// Print the specified object(s).
            /// - Parameters:
            ///   - objects: List of objects to print
            ///   - withProperties: Optional properties for the print command
            @objc optional func print(_ objects: Any!, withProperties: [String: Any]?)

            /// Quit the application.
            @objc(quit) optional func sbQuit()

            /// Close the specified object.
            /// - Parameter object: The object to close
            @objc(close:) optional func sbClose(_ object: SBObject?)

            /// Return the number of elements of a particular class within an object.
            /// - Parameters:
            ///   - object: The object whose elements are to be counted
            ///   - each: The class of elements to count
            /// - Returns: The number of elements
            @objc optional func count(_ object: Any!, each: Any!) -> Int

            /// Return the size in bytes of an object.
            /// - Parameters:
            ///   - object: The object whose data size is to be returned
            ///   - as: The data type for which the size is calculated (optional)
            /// - Returns: The size of the object in bytes
            @objc optional func dataSize(_ object: Any!, as: Any?) -> Int

            /// Move an item from its container to the trash.
            /// - Parameter object: The item to delete
            /// - Returns: The item that was just deleted
            @objc(delete:) optional func deleteObject(_ object: Any!) -> Any!

            /// Duplicate one or more object(s).
            /// - Parameters:
            ///   - objects: The object(s) to duplicate
            ///   - to: The new location for the object(s) (optional)
            ///   - replacing: Whether to replace items with the same name (optional)
            ///   - routingSuppressed: Whether to suppress autorouting (optional)
            ///   - exactCopy: Whether to copy permissions/ownership as is (optional)
            /// - Returns: The duplicated object(s)
            @objc(duplicate:to:replacing:routingSuppressed:exactCopy:) optional func sbDuplicate(_ objects: Any!, to: Any?, replacing: Bool, routingSuppressed: Bool, exactCopy: Bool) -> Any!

            /// Verify if an object exists.
            /// - Parameter object: The object in question
            /// - Returns: True if it exists, false if not
            @objc(exists:) optional func sbExists(_ object: Any!) -> Bool

            /// Make a new element.
            /// - Parameters:
            ///   - new: The class of the new element
            ///   - at: The location at which to insert the element
            ///   - to: When creating an alias, the original item (optional)
            ///   - withProperties: Initial values for properties (optional)
            /// - Returns: The new object(s)
            @objc optional func make(new: Any!, at: Any!, to: Any?, withProperties: [String: Any]?) -> Any!

            /// Move object(s) to a new location.
            /// - Parameters:
            ///   - objects: The object(s) to move
            ///   - to: The new location for the object(s)
            ///   - replacing: Whether to replace items with the same name (optional)
            ///   - positionedAt: List of positions for destination items (optional)
            ///   - routingSuppressed: Whether to suppress autorouting (optional)
            /// - Returns: The object(s) after they have been moved
            @objc(move:to:replacing:positionedAt:routingSuppressed:) optional func sbMove(_ objects: Any!, to: Any!, replacing: Bool, positionedAt: [Any]?, routingSuppressed: Bool) -> Any!

            /// Select the specified object(s).
            /// - Parameter object: The object to select
            @objc(select:) optional func sbSelect(_ object: Any!)
        """
        } else {
            // If we have a Standard Suite, add parsed commands from all suites
            if debug {
                print("DEBUG: Adding parsed commands from all suites to SBApplicationProtocol")
            }

            // Group commands by suite for organization
            for suite in model.suites {
                if !suite.commands.isEmpty {
                    code += "\n\n    // MARK: - \(suite.name) Commands\n"
                    if debug {
                        print("DEBUG: Adding \(suite.commands.count) commands from suite '\(suite.name)'")
                    }

                    for command in suite.commands {
                        if debug {
                            print("DEBUG: Generating command: \(command.name)")
                        }
                        let commandCode = generateCommand(command)
                        if debug && command.name == "print" {
                            print("DEBUG: Generated print command code: \(commandCode)")
                        }
                        code += "\n" + commandCode
                    }
                }
            }
        }

        code += """

        }

        """
        if !hasStandardSuite {
            code += """
           public extension \(baseName)SBApplicationProtocol {
               /// Open the specified object(s).
               ///
               /// This method opens the specified objects
               /// using the specified application.
               ///
               /// - Parameters:
               ///   - objects: List of objects to open
               ///   - using: The application file to open the object with
               ///   - with: Initial values for properties
               /// - Returns: `true` if the `open` message could be sent successfully
               @inlinable
               @discardableResult
               func open(objects: SBElementArray, using application: Any? = nil, with properties: [String: Any]? = nil) -> Bool {
                   open?(objects, using: application, withProperties: properties) != nil
               }

               /// Print the specified object(s).
               /// - Parameters:
               ///   - objects: List of objects to print
               ///   - withProperties: Optional properties for the print command
               /// - Returns: `true` if the `print` message could be sent successfully
               @inlinable
               @discardableResult
               func print(_ objects: SBElementArray? = nil, with properties: [String: Any]? = nil) -> Bool {
                   print?(objects, withProperties: properties) != nil
               }

               /// Quit the application.
               /// - Returns: `true` if the `quit` message could be sent successfully
               @inlinable
               @discardableResult
               func quit() -> Bool {
                   sbQuit?() != nil
               }

               /// Close the specified object.
               /// - Parameter object: The object to close
               /// - Returns: `true` if the `close` message could be sent successfully
               @inlinable
               @discardableResult
               func close(_ object: SBObject) -> Bool {
                   sbClose?(object) != nil
               }

               /// Return the number of elements of a particular class within an object.
               /// - Parameters:
               ///   - object: The object whose elements are to be counted
               ///   - ofKind: The class of elements to count
               /// - Returns: The number of elements, or `nil` if the count could not be determined
               @inlinable
               func count(_ object: SBObject, ofKind kind: SBObject? = nil) -> Int? {
                   count?(object, each: kind)
               }

               /// Return the size in bytes of an object.
               /// - Parameters:
               ///   - object: The object whose data size is to be returned
               ///   - as: The data type for which the size is calculated (optional)
               /// - Returns: The size of the object in bytes, or `nil` if the size could not be determined
               @inlinable
               func dataSize(of object: SBObject, as dataType: SBObject? = nil) -> Int? {
                   dataSize?(object, as: dataType)
               }

               /// Move an item from its container to the trash.
               ///
               /// This method removes an item from its container to the trash.
               /// - Parameter object: The item to delete
               /// - Returns: The item that was just deleted, or `nil` if the deletion failed
               @inlinable
               @discardableResult
               func delete(_ object: SBObject) -> SBObject! {
                   deleteObject?(object) as? SBObject
               }

               /// Duplicate one or more object(s).
               ///
               /// This method duplicates one or more object(s) in the receiver.
               /// - Parameters:
               ///   - objects: The object(s) to duplicate
               ///   - to: The new location for the object(s) (optional)
               ///   - replacing: Whether to replace items with the same name (optional)
               ///   - routingSuppressed: Whether to suppress autorouting (optional)
               ///   - exactCopy: Whether to copy permissions/ownership as is (optional)
               /// - Returns: The duplicated object(s), or `nil` if the duplication failed
               @inlinable
               @discardableResult
               func duplicate(_ objects: Any!, to: Any? = false, replacing: Bool = false, routingSuppressed: Bool = false, exactCopy: Bool = false) -> Any! {
                   sbDuplicate?(objects, to: to, replacing: replacing, routingSuppressed: routingSuppressed, exactCopy: exactCopy)
               }

               /// Verify if an object exists.
               ///
               /// This method checks if an object exists in the receiver.
               /// - Parameter object: The object in question
               /// - Returns: True if it exists, false if not, or `nil` if the check failed
               @inlinable
               func exists(_ object: Any!) -> Bool? {
                   sbExists?(object)
               }

               /// Make a new element.
               /// - Parameters:
               ///   - new: The class of the new element
               ///   - at: The location at which to insert the element
               ///   - to: When creating an alias, the original item (optional)
               ///   - with: Initial values for properties (optional)
               /// - Returns: The new object(s) or `nil` if the creation failed
               @inlinable
               @discardableResult
               func makeNewInstance(of objectClass: SBObject, at location: SBObject!, to alias: SBObject? = nil, with properties: [String: Any]? = nil) -> Any! {
                   make?(new: objectClass, at: location, to: alias, withProperties: properties)
               }

               /// Move object(s) to a new location.
               /// - Parameters:
               ///   - objects: The object(s) to move
               ///   - to: The new location for the object(s)
               ///   - replacing: Whether to replace items with the same name (optional)
               ///   - positionedAt: List of positions for destination items (optional)
               ///   - routingSuppressed: Whether to suppress autorouting (optional)
               /// - Returns: The object(s) after they have been moved
               @inlinable
               @discardableResult
               func move(_ objects: Any!, to: Any!, replacing: Bool, positionedAt: [Any]?, routingSuppressed: Bool) -> Any! {
                   sbMove?(objects, to: to, replacing: replacing, positionedAt: positionedAt, routingSuppressed: routingSuppressed)
               }

               /// Select the specified object(s).
               /// - Parameter object: The object to select
               @inlinable
               @discardableResult
               func select(_ object: Any!) -> Bool {
                   sbSelect?(object) != nil
               }
           }

           """
        }
        code += """
        extension SBApplication: \(baseName)SBApplicationProtocol {}

        """


        // Generate standard protocols and enums first (outside namespace)
        code += generateApplicationProtocol()

        // Generate convenience methods for application protocol (after protocol definition)
        code += generateApplicationProtocolConvenienceMethods()

        // Start namespace enum
        code += "\n\n// MARK: - \(baseName) Namespace\n\n"
        code += "/// Namespace for all \(baseName) scripting types.\n"
        code += "public enum \(baseName) {\n"

        // Generate type aliases inside namespace
        code += generateNamespacedTypeAliases()

        // Generate standard enums inside namespace
        code += generateNamespacedStandardEnums()

        // Generate class names enum if requested
        if shouldGenerateClassNamesEnum {
            code += generateNamespacedClassNamesEnum()
        }

        // Generate enumerations inside namespace - deduplicate by name
        var generatedEnumNames = Set<String>()
        for suite in model.suites {
            for enumeration in suite.enumerations {
                let enumName = enumeration.name.swiftClassName
                if !generatedEnumNames.contains(enumName) {
                    code += generateNamespacedEnumeration(enumeration)
                    generatedEnumNames.insert(enumName)
                } else if verbose {
                    print("Skipping duplicate enumeration: \(enumName)")
                }
            }
        }

        // Generate protocols for standard classes that haven't been merged (inside namespace)
        let mergedClassNames = Set(model.suites.flatMap { $0.classes }.map { $0.name })
        var generatedClassNames = Set<String>()
        for standardClass in model.standardClasses {
            // Only generate if this standard class hasn't been merged into a regular class
            if !mergedClassNames.contains(standardClass.name) {
                code += generateNamespacedClassProtocol(standardClass, suite: SDEFSuite(name: "Standard", code: "std", description: "Standard classes", classes: [], enumerations: [], commands: [], classExtensions: []))
            }
        }

        // Generate protocols for classes (inside namespace)
        for suite in model.suites {
            if debug {
                print("DEBUG: Processing suite '\(suite.name)' with \(suite.classes.count) classes and \(suite.classExtensions.count) class extensions")
                for sdefClass in suite.classes {
                    print("DEBUG:   Regular class: '\(sdefClass.name)'")
                }
                for classExtension in suite.classExtensions {
                    print("DEBUG:   Class extension: extends '\(classExtension.extends)'")
                }
            }

            for sdefClass in suite.classes {
                // Check if we already generated a protocol for this class name
                let className = sdefClass.name.lowercased()

                // Simply skip if we already generated this class from another suite (prevent duplicates)
                let alreadyGenerated = generatedClassNames.contains(className)

                if debug && alreadyGenerated {
                    print("DEBUG: Skipping duplicate class '\(sdefClass.name)' from suite '\(suite.name)' (already generated)")
                }

                if !alreadyGenerated {
                    generatedClassNames.insert(className)
                    code += generateNamespacedClassProtocol(sdefClass, suite: suite)
                }
            }

            // Generate protocols for class extensions (inside namespace)
            // Only generate if they weren't merged into existing classes
            for classExtension in suite.classExtensions {
                let extendedClassName = classExtension.extends.lowercased()

                // Check if there's already a regular class with this name in any suite
                let hasExistingClass = model.suites.flatMap { $0.classes }.contains {
                    $0.name.lowercased() == extendedClassName
                } || model.standardClasses.contains {
                    $0.name.lowercased() == extendedClassName
                }

                if debug {
                    print("DEBUG: Processing class extension '\(classExtension.extends)' (lowercased: '\(extendedClassName)')")
                    print("DEBUG: hasExistingClass = \(hasExistingClass)")
                    let allClasses = model.suites.flatMap { $0.classes }.map { $0.name.lowercased() } + model.standardClasses.map { $0.name.lowercased() }
                    print("DEBUG: All classes: \(allClasses)")
                }

                // Only generate separate protocol if no existing class found
                // (meaning the extension extends a class from another SDEF or system class)
                if !hasExistingClass {
                    code += generateNamespacedClassExtensionProtocol(classExtension, suite: suite)
                } else if debug {
                    print("DEBUG: Skipping class extension protocol for '\(classExtension.extends)' because existing class found")
                }
            }
        }

        // Generate application() convenience function if bundle identifier is provided
        if let bundleIdentifier = bundleIdentifier {
            code += generateApplicationFunction(bundleIdentifier: bundleIdentifier)
        }

        // Close namespace enum
        code += "\n}\n"

        // Generate SBObject extensions for namespaced protocols
        code += generateNamespacedSBObjectExtensions()

        // Generate strongly typed extensions if requested
        if shouldGenerateStronglyTypedExtensions {
            code += generateStronglyTypedExtensions()
        }

        // Generate SBApplication extension
        code += generateSBApplicationExtension()

        // Generate prefixed typealiases if requested
        if generatePrefixedTypealiases {
            code += generatePrefixedTypealiasesSection()
        }

        // Generate flat typealiases if requested
        if generateFlatTypealiases {
            code += generateFlatTypealiasesSection()
        }

        return code
    }

    private func generateTypeAliases() -> String {
        // Check if the SDEF model defines an Application class
        let hasApplicationClass = model.suites.contains { suite in
            suite.classes.contains { sdefClass in
                sdefClass.name.lowercased() == "application"
            }
        }

        var aliases = """

// MARK: - Type Aliases

"""

        if !hasApplicationClass {
            aliases += "public typealias \(baseName)Application = SBApplication\n"
        }

        aliases += """
public typealias \(baseName)Object = SBObject
public typealias \(baseName)ElementArray = SBElementArray

"""
        return aliases
    }

    private func generateEnumeration(_ enumeration: SDEFEnumeration) -> String {
        let enumName = "\(baseName)\(enumeration.name.capitalisedFirstLetter.replacingOccurrences(of: " ", with: "").replacingOccurrences(of: "-", with: ""))"

        var code = """

        // MARK: - \(enumeration.name)

        """

        if let description = enumeration.description {
            code += "/// \(description.capitalisedFirstLetter)\n"
        }

        code += "@objc public enum \(enumName): AEKeyword, Sendable {\n"

        // Track used raw values and their corresponding case names
        var usedRawValues: [String: String] = [:]
        var aliasProperties: [String] = []

        for enumerator in enumeration.enumerators {
            if let description = enumerator.description {
                code += "    /// \(description.capitalisedFirstLetter)\n"
            }

            let caseName = enumerator.name.swiftCaseName
            let codeValue = enumerator.code.formattedEnumeratorCode

            // Check if we've already used this raw value
            if let existingCaseName = usedRawValues[codeValue] {
                // Create an alias property instead of a duplicate case
                if verbose {
                    print("Creating alias \(caseName) -> \(existingCaseName) for duplicate raw value \(codeValue) in \(enumName)")
                }
                aliasProperties.append("    /// Alias for \(existingCaseName)")
                aliasProperties.append("    public static let \(caseName): \(enumName) = .\(existingCaseName)")
            } else {
                // This is a new raw value, create the actual case
                usedRawValues[codeValue] = caseName
                code += "    case \(caseName) = \(codeValue)\n"
            }
        }

        // Add alias properties after the cases
        if !aliasProperties.isEmpty {
            code += "\n    // MARK: - Aliases for duplicate raw values\n"
            for aliasProperty in aliasProperties {
                code += "\(aliasProperty)\n"
            }
        }

        code += "}\n"

        return code
    }

    private func generateClassProtocol(_ sdefClass: SDEFClass, suite: SDEFSuite) -> String {
        let protocolName = "\(baseName)\(sdefClass.name.swiftClassName)"

        var code = """

        // MARK: - \(sdefClass.name)

        """

        if let description = sdefClass.description {
            code += "/// \(description.capitalisedFirstLetter)\n"
        }

        var inheritanceList: [String]

        // Application classes should inherit from ApplicationProtocol, others from SBObjectProtocol
        // Always use prefixed versions to avoid conflicts between different SDEF files
        if sdefClass.name.lowercased() == "application" {
            inheritanceList = ["\(baseName)ApplicationProtocol"]
        } else {
            inheritanceList = ["\(baseName)SBObjectProtocol"]
        }

        // Add GenericMethods for standard classes
        if ["window", "document", "application"].contains(sdefClass.name.lowercased()) {
            inheritanceList.append("\(baseName)GenericMethods")
        }

        if let inherits = sdefClass.inherits {
            let cleanInherits = inherits.swiftClassName

            // Check if the inherited class actually exists in the model
            let allClasses = model.suites.flatMap { $0.classes } + model.standardClasses
            let inheritsClassExists = allClasses.contains { $0.name.lowercased() == inherits.lowercased() }

            if inheritsClassExists {
                // If the inherited class name conflicts with the namespace name, add "Protocol" suffix
                if cleanInherits == baseName {
                    inheritanceList.append("\(baseName)\(cleanInherits)Protocol")
                } else {
                    inheritanceList.append("\(baseName)\(cleanInherits)")
                }
            } else if verbose {
                print("Warning: Class '\(sdefClass.name)' inherits from '\(inherits)' but '\(inherits)' is not defined in the SDEF model")
            }
        }

        code += "@objc public protocol \(protocolName): \(inheritanceList.joined(separator: ", ")) {\n"

        // Generate properties
        for property in sdefClass.properties {
            code += generateProperty(property)
        }

        // Generate element arrays
        for element in sdefClass.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
            ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = pluralName.swiftMethodName
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = pluralForm.swiftMethodName
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "    /// Array of \(element.type) objects - \(description.lowercasedFirstLetter)\n"
            }

            code += "    @objc(\(methodName)) optional func untyped\(methodName.capitalisedFirstLetter)() -> SBElementArray\n"
        }

        // Generate setter methods only for write-only properties
        for property in sdefClass.properties {
            if property.access == "w" { // Write-only properties need explicit setter methods
                let propertyName = if let cocoaKey = property.cocoaKey {
                    // Cocoa keys are already in proper Swift naming convention
                    cocoaKey.escapedReservedKeyword
                } else {
                    property.name.swiftPropertyName
                }
                let swiftType = swiftSetterParameterType(for: property.type)

                // Generate DocC comment for setter
                if let description = property.description {
                    let setterDescription = "Set \(description.lowercasedFirstLetter)"
                    code += "    /// \(setterDescription.capitalisedFirstLetter)\n"
                }

                // Fix setter naming for special cases
                let setterName = switch property.name.lowercased() {
                case "current tab":
                    "CurrentTab"
                case "url":
                    "URL"
                default:
                    property.name.swiftClassName
                }

                code += "    @objc optional func set\(setterName)(_ \(propertyName): \(swiftType))\n"
            }
        }

        code += "}\n"

        // Generate extension - SBApplication for application classes, SBObject for others
        if sdefClass.name.lowercased() == "application" {
            code += """

            extension SBApplication: \(protocolName) {}

            """
        } else {
            code += """

            extension SBObject: \(protocolName) {}

            """
        }

        return code
    }

    private func generateClassExtensionProtocol(_ classExtension: SDEFClassExtension, suite: SDEFSuite) -> String {
        let baseTypeName = classExtension.extends.swiftClassName
        let protocolName = "\(baseName)\(baseTypeName)"

        var code = """

        // MARK: - \(classExtension.extends) Extension

        @objc public protocol \(protocolName): SBObject {

        """

        // Generate properties
        for property in classExtension.properties {
            code += generateProperty(property)
        }

        // Generate element arrays
        for element in classExtension.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
            ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = pluralName.swiftMethodName
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = pluralForm.swiftMethodName
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "    /// Array of \(element.type) objects - \(description.lowercasedFirstLetter)\n"
            }

            code += "    @objc(\(methodName)) optional func untyped\(methodName.capitalisedFirstLetter)() -> SBElementArray\n"
        }

        code += "}\n"

        // Generate SBObject extension
        code += """

        extension SBObject: \(protocolName) {}

        """

        return code
    }

    private func generateNamespacedClassProtocol(_ sdefClass: SDEFClass, suite: SDEFSuite) -> String {
        var protocolName = sdefClass.name.swiftClassName

        // If the protocol name would conflict with the namespace name, add "Protocol" suffix
        if protocolName == baseName {
            protocolName = "\(protocolName)Protocol"
        }

        var code = """

            // MARK: - \(sdefClass.name)

        """

        if let description = sdefClass.description {
            code += "    /// \(description.capitalisedFirstLetter)\n"
        }

        var inheritanceList: [String]

        // Application classes should inherit from ApplicationProtocol, others from SBObjectProtocol
        // Use prefixed versions from outside the namespace
        if sdefClass.name.lowercased() == "application" {
            inheritanceList = ["\(baseName)ApplicationProtocol"]
        } else {
            inheritanceList = ["\(baseName)SBObjectProtocol"]
        }

        // Add GenericMethods for standard classes
        if ["window", "document", "application"].contains(sdefClass.name.lowercased()) {
            inheritanceList.append("\(baseName)GenericMethods")
        }

        if let inherits = sdefClass.inherits {
            let cleanInherits = inherits.swiftClassName

            // Check if the inherited class actually exists in the model
            let allClasses = model.suites.flatMap { $0.classes } + model.standardClasses
            let inheritsClassExists = allClasses.contains { $0.name.lowercased() == inherits.lowercased() }

            if inheritsClassExists {
                // Reference within the same namespace
                // If the inherited class name conflicts with the namespace name, add "Protocol" suffix
                if cleanInherits == baseName {
                    inheritanceList.append("\(cleanInherits)Protocol")
                } else {
                    inheritanceList.append(cleanInherits)
                }
            } else if verbose {
                print("Warning: Class '\(sdefClass.name)' inherits from '\(inherits)' but '\(inherits)' is not defined in the SDEF model")
            }
        }

        code += "    @objc(\(baseName)\(protocolName)) public protocol \(protocolName): \(inheritanceList.joined(separator: ", ")) {\n"

        // Generate properties
        for property in sdefClass.properties {
            code += generateNamespacedProperty(property)
        }

        // Generate element arrays
        for element in sdefClass.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
            ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = pluralName.swiftMethodName
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = pluralForm.swiftMethodName
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "        /// Array of \(element.type) objects - \(description.lowercasedFirstLetter)\n"
            }

            code += "        @objc(\(methodName)) optional func untyped\(methodName.capitalisedFirstLetter)() -> SBElementArray\n"
        }

        // Generate setter methods only for write-only properties
        for property in sdefClass.properties {
            if property.access == "w" { // Write-only properties need explicit setter methods
                let propertyName = if let cocoaKey = property.cocoaKey {
                    // Cocoa keys are already in proper Swift naming convention
                    cocoaKey.escapedReservedKeyword
                } else {
                    property.name.swiftPropertyName
                }
                let swiftType = swiftSetterParameterType(for: property.type)

                // Generate DocC comment for setter
                if let description = property.description {
                    let setterDescription = "Set \(description.lowercasedFirstLetter)"
                    code += "        /// \(setterDescription.capitalisedFirstLetter)\n"
                }

                // Fix setter naming for special cases
                let setterName = switch property.name.lowercased() {
                case "current tab":
                    "CurrentTab"
                case "url":
                    "URL"
                default:
                    propertyName.capitalisedFirstLetter
                }

                code += "        @objc optional func set\(setterName)(_ \(propertyName): \(swiftType))\n"
            }
        }

        // Add suite commands to Application class
        if sdefClass.name.lowercased() == "application" {
            if debug {
                print("DEBUG: Generating commands for Application class")
                print("DEBUG: Model has \(model.suites.count) suites")
            }
            // Add commands from all suites
            for modelSuite in model.suites {
                if debug {
                    print("DEBUG: Suite '\(modelSuite.name)' has \(modelSuite.commands.count) commands")
                }
                if !modelSuite.commands.isEmpty {
                    if debug {
                        print("DEBUG: Adding commands section for \(modelSuite.name)")
                    }
                    code += "\n        // MARK: - \(modelSuite.name) Commands\n"
                    for command in modelSuite.commands {
                        if debug {
                            print("DEBUG: Adding command: \(command.name)")
                        }
                        let commandCode = generateCommand(command)
                        if debug {
                            print("DEBUG: Generated command code: \(commandCode)")
                        }
                        code += commandCode
                    }
                } else if debug {
                    print("DEBUG: No commands to add for \(modelSuite.name)")
                }
            }
        }

        code += "    }\n"

        return code
    }

    private func generateNamespacedClassExtensionProtocol(_ classExtension: SDEFClassExtension, suite: SDEFSuite) -> String {
        let baseTypeName = classExtension.extends.swiftClassName
        let protocolName = baseTypeName

        var code = """

            // MARK: - \(classExtension.extends) Extension

            @objc(\(baseName)\(protocolName)) public protocol \(protocolName): SBObject {

        """

        // Generate properties
        for property in classExtension.properties {
            code += generateNamespacedProperty(property)
        }

        // Generate element arrays
        for element in classExtension.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
            ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = pluralName.swiftMethodName
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = pluralForm.swiftMethodName
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "        /// Array of \(element.type) objects - \(description.lowercasedFirstLetter)\n"
            }

            code += "        @objc(\(methodName)) optional func untyped\(methodName.capitalisedFirstLetter)() -> SBElementArray\n"
        }

        code += "    }\n"

        return code
    }

    private func generateNamespacedProperty(_ property: SDEFProperty) -> String {
        var code = ""

        if let description = property.description {
            code += "        /// \(description.capitalisedFirstLetter)\n"
        }

        // Protocol should use the original SDEF property name (Objective-C style)
        // This provides the canonical property names that match AppleScript/Objective-C conventions
        let basePropertyName = property.name.swiftPropertyName

        // For list properties, use "untyped" prefix and SBElementArray
        let (propertyName, swiftType) = if property.type.isList {
            ("untyped" + basePropertyName.capitalisedFirstLetter, "SBElementArray")
        } else {
            (basePropertyName, swiftNamespacedType(for: property.type))
        }

        // Always use the original SDEF property name for @objc attribute for ABI compatibility
        let objcName = property.name.swiftPropertyName

        // Check if this is a non-primitive type that needs special handling
        let needsSeparateMethods = !basicSwiftTypes.contains(swiftType) && !property.type.isList

        if needsSeparateMethods {
            // Generate separate getter and setter methods using the property code
            // to avoid naming conflicts with the Swift convenience property
            // Use both code and property name to ensure uniqueness
            let codeBaseName = property.code.swiftClassName
            let nameBaseName = String(property.name.swiftClassName.replacingOccurrences(of: " ", with: ""))
            let methodBaseName = "\(codeBaseName)\(nameBaseName)"

            // Always generate getter if not write-only
            if property.access != "w" {
                code += "        @objc(\(objcName)) optional func get\(methodBaseName)() -> \(swiftType)\n"
            }

            // Always generate setter if not read-only
            if property.access != "r" {
                // Add setter documentation if property has description
                if let description = property.description {
                    code += "        /// Set \(description.lowercasedFirstLetter)\n"
                }
                code += "        @objc(set\(objcName.capitalisedFirstLetter):) optional func set\(methodBaseName)(_ value: \(swiftType))\n"
            }
        } else {
            // Use regular property syntax for primitive types and lists
            let accessors = switch property.access {
            case "r":
                "{ get }"
            case "rw", "":
                "{ get set }"
            case "w":
                "{ get set }" // Even write-only properties need to be readable in Swift protocols
            default:
                "{ get set }"
            }

            if objcName != propertyName {
                code += "        @objc(\(objcName)) optional var \(propertyName): \(swiftType) \(accessors)\n"
            } else {
                code += "        @objc optional var \(propertyName): \(swiftType) \(accessors)\n"
            }
        }

        return code
    }

    private func generateNamespacedSBObjectExtensions() -> String {
        var code = ""
        var generatedExtensionNames = Set<String>()

        // Generate extensions for standard classes that haven't been merged
        let mergedClassNames = Set(model.suites.flatMap { $0.classes }.map { $0.name })
        for standardClass in model.standardClasses {
            // Only generate if this standard class hasn't been merged into a regular class
            if !mergedClassNames.contains(standardClass.name) {
                var protocolName = standardClass.name.swiftClassName
                // If the protocol name conflicts with the namespace name, add "Protocol" suffix
                if protocolName == baseName {
                    protocolName = "\(protocolName)Protocol"
                }
                let extensionKey = "\(protocolName.lowercased())"
                if !generatedExtensionNames.contains(extensionKey) {
                    generatedExtensionNames.insert(extensionKey)
                    if standardClass.name.lowercased() == "application" {
                        code += "\nextension SBApplication: \(baseName).\(protocolName) {}\n"
                    } else {
                        code += "\nextension SBObject: \(baseName).\(protocolName) {}\n"
                    }
                }
            }
        }

        // Generate extensions for regular classes
        for suite in model.suites {
            for sdefClass in suite.classes {
                var protocolName = sdefClass.name.swiftClassName
                // If the protocol name conflicts with the namespace name, add "Protocol" suffix
                if protocolName == baseName {
                    protocolName = "\(protocolName)Protocol"
                }
                let extensionKey = "\(protocolName.lowercased())"
                if !generatedExtensionNames.contains(extensionKey) {
                    generatedExtensionNames.insert(extensionKey)
                    if sdefClass.name.lowercased() == "application" {
                        code += "\nextension SBApplication: \(baseName).\(protocolName) {}\n"
                    } else {
                        code += "\nextension SBObject: \(baseName).\(protocolName) {}\n"
                    }
                }
            }

            // Generate extensions for class extensions
            // Only generate if they weren't merged into existing classes
            for classExtension in suite.classExtensions {
                let extendedClassName = classExtension.extends.lowercased()

                // Check if there's already a regular class with this name in any suite
                let hasExistingClass = model.suites.flatMap { $0.classes }.contains {
                    $0.name.lowercased() == extendedClassName
                } || model.standardClasses.contains {
                    $0.name.lowercased() == extendedClassName
                }

                // Only generate extension if no existing class found
                if !hasExistingClass {
                    var protocolName = classExtension.extends.swiftClassName
                    // If the protocol name conflicts with the namespace name, add "Protocol" suffix
                    if protocolName == baseName {
                        protocolName = "\(protocolName)Protocol"
                    }
                    let extensionKey = "\(protocolName.lowercased())"
                    if !generatedExtensionNames.contains(extensionKey) {
                        generatedExtensionNames.insert(extensionKey)
                        code += "\nextension SBObject: \(baseName).\(protocolName) {}\n"
                    }
                }
            }
        }

        return code
    }

    private func generateProperty(_ property: SDEFProperty) -> String {
        var code = ""

        if let description = property.description {
            code += "    /// \(description.capitalisedFirstLetter)\n"
        }

        // Use cocoa key if available, otherwise use the property name
        let basePropertyName = if let cocoaKey = property.cocoaKey {
            // Cocoa keys are already in proper Swift naming convention (e.g., isShared)
            // Just escape reserved keywords if needed
            cocoaKey.escapedReservedKeyword
        } else {
            property.name.swiftPropertyName
        }

        // For list properties, use "untyped" prefix and SBElementArray
        let (propertyName, swiftType) = if property.type.isList {
            ("untyped" + basePropertyName.capitalisedFirstLetter, "SBElementArray")
        } else {
            (basePropertyName, swiftType(for: property.type))
        }

        // Always use the original SDEF property name for @objc attribute for ABI compatibility
        let objcName = property.name.swiftPropertyName

        // Check if this is a non-primitive type that needs special handling
        let needsSeparateMethods = !basicSwiftTypes.contains(swiftType) && !property.type.isList

        if needsSeparateMethods {
            // Generate separate getter and setter methods using the property code
            // to avoid naming conflicts with the Swift convenience property
            // Use both code and property name to ensure uniqueness
            let codeBaseName = property.code.swiftClassName
            let nameBaseName = String(property.name.swiftClassName.replacingOccurrences(of: " ", with: ""))
            let methodBaseName = "\(codeBaseName)\(nameBaseName)"

            // Always generate getter if not write-only
            if property.access != "w" {
                code += "    @objc(\(objcName)) optional func get\(methodBaseName)() -> \(swiftType)\n"
            }

            // Always generate setter if not read-only
            if property.access != "r" {
                // Add setter documentation if property has description
                if let description = property.description {
                    code += "    /// Set \(description.lowercasedFirstLetter)\n"
                }
                let setterType = swiftSetterParameterType(for: property.type)
                code += "    @objc(set\(objcName.capitalisedFirstLetter):) optional func set\(methodBaseName)(_ value: \(setterType))\n"
            }
        } else {
            // Use regular property syntax for primitive types and lists
            let accessors = switch property.access {
            case "r":
                " { get }"
            case "w":
                " { set }"
            default:
                " { get set }"
            }
            code += "    @objc(\(objcName)) optional var \(propertyName): \(swiftType)\(accessors)\n"
        }

        return code
    }

    private func getSaveOptionsTypeFromSDEF() -> String {
        // Look for the 'close' command and find its 'saving' parameter type
        for suite in model.suites {
            for command in suite.commands {
                if command.name.lowercased() == "close" {
                    for parameter in command.parameters {
                        if parameter.name?.lowercased() == "saving" {
                            // Found the saving parameter, now convert its type to Swift
                            let swiftTypeName = swiftUnprefixedTypeName(parameter.type.baseType)
                            return "\(baseName).\(swiftTypeName)"
                        }
                    }
                }
            }
        }
        // Fallback to SaveOptions if no close/saving command found
        return "\(baseName).SaveOptions"
    }

    private func generateApplicationProtocol() -> String {
        // Always use prefixed base protocol to avoid conflicts between different SDEF files
        let applicationBaseProtocol = "\(baseName)SBApplicationProtocol"

        if debug {
            print("DEBUG: generateApplicationProtocol called for \(baseName)")
            print("DEBUG: Model has \(model.suites.count) suites")
            for suite in model.suites {
                print("DEBUG: Suite '\(suite.name)' has \(suite.commands.count) commands")
            }
        }

        var code = """

        // MARK: - Generic Methods Protocol

        @objc public protocol \(baseName)GenericMethods {
            /// Close the object.
            ///
            /// This closes the receiver object,
            /// optionally saving it.
            /// - Parameters:
            ///   - saving: The save option to use (`.no`, `.yes`, or `.ask`).
            ///   - savingIn: The URL to save the object in or `nil` for the default location.
            @objc optional func closeSaving(_ saving: \(getSaveOptionsTypeFromSDEF()), savingIn: URL?)
            /// Save the object.
            ///
            /// This saves the receiver object.
            /// - Parameters:
            ///   - url: The URL to save the object in or `nil` for the default location.
            ///   - as: The format to save the object as or `nil` for the default format.
            @objc optional func saveIn(_ url: URL?, as: Any?)
            /// Print the object.
            ///
            /// This prints the receiver object.
            /// - Parameters:
            ///   - withProperties: The properties to use for printing or `nil` for the default properties.
            ///   - printDialog: Whether to show the print dialog or not.
            @objc optional func printWithProperties(_ withProperties: [String: Any]?, printDialog: Bool)
            /// Delete the receiver.
            ///
            /// This deletes the receiver object.
            @objc(delete) optional func sbDelete()
            /// Duplicate the receiver.
            ///
            /// This duplicates the receiver object.
            /// - Parameters:
            ///   - to: The location to duplicate the object to or `nil` for the default location.
            ///   - withProperties: The properties to use for duplication or `nil` for the default properties.
            @objc optional func duplicateTo(_ to: SBObject?, withProperties: [String: Any]?)
            /// Move the object.
            ///
            /// This moves the receiver object.
            /// - Parameters:
            ///   - to: The location to move the object to or `nil` for the default location.
            @objc optional func moveTo(_ to: SBObject?)
        }

        public extension \(baseName)GenericMethods {
            /// Close the object.
            ///
            /// This closes the receiver object,
            /// optionally saving it.
            /// - Parameters:
            ///   - saving: `.yes` to save, `.no` to discard, `.ask` to ask.
            ///   - url: The URL to save the object to or `nil` for the default URL.
            @inlinable
            func close(saving: \(getSaveOptionsTypeFromSDEF()) = .ask, url: URL? = nil) {
                closeSaving?(saving, savingIn: url)
            }
            /// Save the object.
            ///
            /// This saves the receiver object.
            /// - Parameters:
            ///   - to: The URL to save the object to or `nil` for the default URL.
            ///   - as: The format to save the object as or `nil` for the default format.
            @inlinable
            func save(to url: URL? = nil, as format: Any? = nil) {
                saveIn?(url, as: format)
            }
            /// Print the object.
            ///
            /// This prints the receiver object.
            /// - Parameters:
            ///   - properties: The properties to print the object with.
            ///   - showingPrintDialog: Whether to show the print dialog.
            @inlinable
            func print(properties: [String: Any]? = nil, showingPrintDialog: Bool = false) {
                printWithProperties?(properties, printDialog: showingPrintDialog)
            }
            /// Delete the receiver.
            ///
            /// This deletes the receiver object.
            @inlinable
            @discardableResult
            func delete() -> Bool {
                sbDelete?() != nil
            }
            /// Duplicate the object.
            ///
            /// This duplicates the receiver object.
            /// - Parameters:
            ///   - to: The destination object or `nil` for the default destination.
            ///   - properties: The properties to set on the duplicated object.
            @inlinable
            func duplicate(to destination: SBObject? = nil, properties: [String: Any]? = nil) {
                duplicateTo?(destination, withProperties: properties)
            }
            /// Move the object.
            ///
            /// This moves the receiver object.
            /// - Parameters:
            ///   - to: The destination object or `nil` for the default destination.
            @inlinable
            func move(to destination: SBObject? = nil) {
                moveTo?(destination)
            }
        }

        // MARK: - Application Protocol

        @objc public protocol \(baseName)ApplicationProtocol: \(applicationBaseProtocol) {
            /// Array of document objects - A document.
            @objc optional func documents() -> SBElementArray
            /// Array of window objects - A window.
            @objc optional func windows() -> SBElementArray
        """

        // Add commands from all suites
        for suite in model.suites {
            if debug {
                print("DEBUG: Processing suite '\(suite.name)' with \(suite.commands.count) commands")
            }
            if !suite.commands.isEmpty {
                code += "\n    // MARK: - \(suite.name) Commands\n"
                for command in suite.commands {
                    if debug {
                        print("DEBUG: Generating command: \(command.name)")
                    }
                    code += generateCommand(command)
                }
            }
        }

        code += "}\n\n"

        return code
    }

    private func generateApplicationFunction(bundleIdentifier: String) -> String {
        // Check if the SDEF model defines an Application class (either in suites or standardClasses)
        let hasApplicationClassInSuites = model.suites.contains { suite in
            suite.classes.contains { sdefClass in
                sdefClass.name.lowercased() == "application"
            }
        }

        let hasApplicationClassInStandard = model.standardClasses.contains { sdefClass in
            sdefClass.name.lowercased() == "application"
        }

        let hasApplicationClass = hasApplicationClassInSuites || hasApplicationClassInStandard

        guard hasApplicationClass else {
            // If there's no Application class defined, don't generate the function
            return ""
        }

        return """

            // MARK: - Application Convenience Function

            /// Return an instance of the application.
            ///
            /// This property creates an instance of the application using its bundle identifier
            /// and returns an optional Application instance if the application is available
            public static var application: \(baseName).Application! {
                SBApplication(bundleIdentifier: "\(bundleIdentifier)")
            }
        """
    }

    private func generateSBApplicationExtension() -> String {
        return """

        extension SBApplication: \(baseName)ApplicationProtocol {}

        extension SBObject: \(baseName)GenericMethods {}

        """
    }

    // MARK: - Helper Methods

    private func generateApplicationProtocolConvenienceMethods() -> String {
        var code = "\n// MARK: - \(baseName)ApplicationProtocol Convenience Methods\n\n"
        code += "public extension \(baseName)ApplicationProtocol {\n"

        // Collect all commands from all suites for the application
        for suite in model.suites {
            if !suite.commands.isEmpty {
                code += "\n    // MARK: \(suite.name) Commands\n"

                for command in suite.commands {
                    code += generateConvenienceMethod(for: command)
                }
            }
        }

        code += "}\n"

        return code
    }

    private func generateConvenienceMethod(for command: SDEFCommand) -> String {
        var code = ""

        // Add documentation
        if let description = command.description {
            code += "    /// \(description.capitalisedFirstLetter)\n"
        }

        // Generate parameter documentation
        var hasDocParams = false
        if let directParam = command.directParameter, let description = directParam.description {
            if !hasDocParams {
                code += "    /// - Parameters:\n"
                hasDocParams = true
            }
            code += "    ///   - directParameter: \(description.capitalisedFirstLetter)\n"
        }

        for param in command.parameters {
            if let description = param.description {
                if !hasDocParams {
                    code += "    /// - Parameters:\n"
                    hasDocParams = true
                }
                let paramName = param.name ?? "parameter"
                code += "    ///   - \(paramName.swiftParameterName): \(description.capitalisedFirstLetter)\n"
            }
        }

        if let result = command.result {
            var returnDescription = result.description?.capitalisedFirstLetter ?? "The command result"
            if let desc = result.description, desc.lowercased().hasPrefix("to the") {
                returnDescription = "A reference " + desc
            }
            code += "    /// - Returns: \(returnDescription)\n"
        }

        // Add @inlinable attribute for better performance
        code += "    @inlinable\n"

        // Generate method signature with original name
        code += "    func \(command.name.swiftMethodName)("

        var paramStrings: [String] = []

        // Add direct parameter if present
        if let directParam = command.directParameter {
            let paramType = swiftType(for: directParam.type)
            var finalParamType = paramType
            var shouldHaveDefault = false

            if directParam.isOptional {
                // Match protocol method logic: only make object types optional
                if paramType.contains("SBObject") || paramType.contains("URL") || paramType.contains("[") || paramType.contains("Any") {
                    finalParamType = paramType + "?"
                    shouldHaveDefault = true
                }
                // For value types, keep non-optional but add default if appropriate
                else {
                    shouldHaveDefault = true
                }
            }

            var paramString = "_ directParameter: \(finalParamType)"

            // Add default value if appropriate
            if shouldHaveDefault {
                if finalParamType.hasSuffix("?") {
                    paramString += " = nil"
                } else if paramType.lowercased() == "bool" {
                    paramString += " = false"
                } else if enumeration(paramType, hasCase: "ask") {
                    paramString += " = .ask"
                }
            }

            paramStrings.append(paramString)
        }

        // Add named parameters
        for param in command.parameters {
            if let paramName = param.name {
                let swiftParamName = paramName.swiftParameterName
                let paramType = swiftType(for: param.type)
                var finalParamType = paramType
                var shouldHaveDefault = false

                if param.isOptional {
                    // Match protocol method logic: only make object types optional
                    if paramType.contains("SBObject") || paramType.contains("URL") || paramType.contains("[") || paramType.contains("Any") {
                        finalParamType = paramType + "?"
                        shouldHaveDefault = true
                    }
                    // For value types, keep non-optional but add default if appropriate
                    else {
                        shouldHaveDefault = true
                    }
                }

                var paramString = "\(swiftParamName): \(finalParamType)"

                // Add default value if appropriate
                if shouldHaveDefault {
                    if finalParamType.hasSuffix("?") {
                        paramString += " = nil"
                    } else if paramType.lowercased() == "bool" {
                        paramString += " = false"
                    } else if enumeration(paramType, hasCase: "ask") {
                        paramString += " = .ask"
                    }
                }

                paramStrings.append(paramString)
            }
        }

        code += paramStrings.joined(separator: ", ")
        code += ")"

        // Add return type if present
        if let result = command.result {
            let returnType = swiftType(for: result)
            code += " -> \(returnType)!"
        }

        code += " {\n"

        // Generate the method body
        let methodName = command.code.sanitisedCommandCode
        code += "        "

        // For single-line methods, omit the return keyword
        code += "\(methodName)?("

        // Pass parameters
        var callParams: [String] = []
        if let directParam = command.directParameter {
            let paramType = swiftType(for: directParam.type)

            // Only force unwrap if the convenience method parameter is actually optional (ends with ?)
            if directParam.isOptional && (paramType.contains("SBObject") || paramType.contains("URL") || paramType.contains("[") || paramType.contains("Any")) {
                // These types are optional in both protocol and convenience methods, so need force unwrapping
                callParams.append("directParameter")
            } else {
                // Non-optional in convenience method, pass directly
                callParams.append("directParameter")
            }
        }

        for param in command.parameters {
            if let paramName = param.name {
                let swiftParamName = paramName.swiftParameterName
                let objcParamName = paramName.objcParameterName
                let paramType = swiftType(for: param.type)

                // Only force unwrap if the convenience method parameter is actually optional (ends with ?)
                if param.isOptional && (paramType.contains("SBObject") || paramType.contains("URL") || paramType.contains("[") || paramType.contains("Any")) {
                    // These types are optional in both protocol and convenience methods, so pass directly
                    callParams.append("\(objcParamName): \(swiftParamName)")
                } else {
                    // Non-optional in convenience method, pass directly
                    callParams.append("\(objcParamName): \(swiftParamName)")
                }
            }
        }

        code += callParams.joined(separator: ", ")
        code += ")\n"

        code += "    }\n\n"

        return code
    }

    private func generateCommand(_ command: SDEFCommand) -> String {
        var code = ""

        // Add documentation if available
        if let description = command.description {
            code += "    /// \(description.capitalisedFirstLetter)\n"
        }

        // Generate parameter documentation
        var hasDocParams = false
        if let directParam = command.directParameter, let description = directParam.description {
            if !hasDocParams {
                code += "    /// - Parameters:\n"
                hasDocParams = true
            }
            code += "    ///   - directParameter: \(description.capitalisedFirstLetter)\n"
        }

        for param in command.parameters {
            if let description = param.description {
                if !hasDocParams {
                    code += "    /// - Parameters:\n"
                    hasDocParams = true
                }
                let paramName = param.name ?? "parameter"
                code += "    ///   - \(paramName.swiftParameterName): \(description.capitalisedFirstLetter)\n"
            }
        }

        if let result = command.result {
            var returnDescription = result.description?.capitalisedFirstLetter ?? "The command result"
            if let desc = result.description, desc.lowercased().hasPrefix("to the") {
                returnDescription = "A reference " + desc
            }
            code += "    /// - Returns: \(returnDescription)\n"
        }

        // Generate method signature with code as method name and proper @objc selector
        let methodName = command.code.sanitisedCommandCode
        let objcSelector = command.objcSelector
        code += "    @objc(\(objcSelector)) optional func \(methodName)("

        var paramStrings: [String] = []

        // Add direct parameter if present
        if let directParam = command.directParameter {
            let paramType = swiftType(for: directParam.type)
            if directParam.isOptional {
                // Optional direct parameters should be marked as optional for object types
                if paramType.contains("SBObject") || paramType.contains("URL") || paramType.contains("[") || paramType.contains("Any") {
                    paramStrings.append("_ directParameter: \(paramType)?")
                } else {
                    // For non-object types, avoid optionals for @objc compatibility
                    paramStrings.append("_ directParameter: \(paramType)")
                }
            } else {
                paramStrings.append("_ directParameter: \(paramType)")
            }
        }

        // Add named parameters
        for param in command.parameters {
            if let paramName = param.name {
                let swiftParamName = paramName.swiftParameterName
                let paramType = swiftType(for: param.type)
                if param.isOptional {
                    // For optional parameters, only make object types optional to avoid @objc issues
                    if paramType.contains("SBObject") || paramType.contains("URL") || paramType.contains("[") || paramType.contains("Any") {
                        paramStrings.append("\(swiftParamName): \(paramType)?")
                    } else {
                        // For value types like Bool, String, enums, provide defaults or keep non-optional
                        paramStrings.append("\(swiftParamName): \(paramType)")
                    }
                } else {
                    paramStrings.append("\(swiftParamName): \(paramType)")
                }
            }
        }

        code += paramStrings.joined(separator: ", ")
        code += ")"

        // Add return type if present
        if let result = command.result {
            let returnType = swiftType(for: result)
            code += " -> \(returnType)"
        }

        code += "\n"

        return code
    }



    private func swiftType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftTypeName(propertyType.baseType)

        if propertyType.isList {
            // Check if the base type is an enum (not representable in Objective-C arrays)
            let allEnumNames = model.suites.flatMap { $0.enumerations }.map { $0.name.swiftClassName }
            let isEnumType = allEnumNames.contains(baseType)

            if verbose {
                print("Checking list property: baseType='\(baseType)', allEnums=\(allEnumNames), isEnum=\(isEnumType)")
            }

            if isEnumType {
                // For enum arrays, use SBElementArray for @objc compatibility
                if verbose {
                    print("Converting enum array [\(baseType)] to SBElementArray for Objective-C compatibility")
                }
                baseType = "SBElementArray"
            } else {
                // For protocol/class arrays, use Swift array syntax (Objective-C compatible)
                baseType = "[\(baseType)]"
            }
        }

        // For @objc optional properties, never make types optional to avoid double optionals
        // The @objc optional already provides the optionality
        return baseType
    }

    private func swiftSetterParameterType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftTypeName(propertyType.baseType)

        if propertyType.isList {
            baseType = "[\(baseType)]"
        }

        // For setter method parameters, preserve optionality as it's separate from @objc optional
        if propertyType.isOptional {
            baseType += "?"
        }

        return baseType
    }

    /// Check if the given Swift type is an enumeration that contains the specified case
    private func enumeration(_ swiftType: String, hasCase caseName: String) -> Bool {
        // Extract the enum name from the namespaced type (e.g., "TextEdit.Savo" -> "Savo")
        let enumName = if swiftType.contains(".") {
            String(swiftType.split(separator: ".").last ?? "")
        } else {
            swiftType
        }

        // Find the enumeration in the model
        for suite in model.suites {
            for enumeration in suite.enumerations {
                if enumeration.name.swiftClassName == enumName {
                    // Check if this enumeration has the specified enumerator
                    return enumeration.enumerators.contains { enumerator in
                        enumerator.name.lowercased() == caseName.lowercased()
                    }
                }
            }
        }

        return false
    }

    private func swiftUnprefixedTypeName(_ objcType: String) -> String {
        swiftTypeName(objcType, prefixWithBaseName: false)
    }

    private func swiftTypeName(_ objcType: String, prefixWithBaseName: Bool = true) -> String {
        if let swiftType = objcType.typeName {
            return swiftType
        }

        // Check if it's an enumeration type
        let cleanType = objcType.baseType.swiftClassName
        let prefix = prefixWithBaseName ? baseName + "." : ""
        let typeName = if enumerationNames.contains(cleanType) || cleanType != baseName {
            cleanType
        } else { // The class name conflicts with the namespace name, add "Protocol" suffix
            cleanType + "Protocol"
        }
        return prefix + typeName
    }

    private func swiftNamespacedType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftUnprefixedTypeName(propertyType.baseType)

        if propertyType.isList {
            baseType = "[\(baseType)]"
        }

        // For @objc optional properties, never make types optional to avoid double optionals
        // The @objc optional already provides the optionality
        return baseType
    }

    private func generateStronglyTypedExtensions() -> String {
        var code = """

        // MARK: - Strongly Typed Extensions

        """
        var generatedStronglyTypedExtensions = Set<String>()

        // For included files, only process classes from the main suites (not standard classes)
        // For main files, process all classes from main suites
        for suite in model.suites {
            for sdefClass in suite.classes {
                if !sdefClass.elements.isEmpty {
                    let className = sdefClass.name.lowercased()
                    if !generatedStronglyTypedExtensions.contains(className) {
                        generatedStronglyTypedExtensions.insert(className)
                        if verbose {
                            print("Processing class '\(sdefClass.name)' with \(sdefClass.elements.count) elements:")
                        }
                        code += generateStronglyTypedExtension(sdefClass, suite: suite)
                    }
                }
            }
        }

        // For main files only, process standard classes that have elements
        // but skip those that already have corresponding classes in the main suites
        if !isIncludedFile {
            let mainSuiteClassNames = Set(model.suites.flatMap { $0.classes }.map { $0.name.lowercased() })

            for standardClass in model.standardClasses {
                if !standardClass.elements.isEmpty {
                    // Skip standard classes that have corresponding classes in main suites
                    if mainSuiteClassNames.contains(standardClass.name.lowercased()) {
                        if verbose {
                            print("Skipping standard class '\(standardClass.name)' - already defined in main suites")
                        }
                        continue
                    }

                    let className = standardClass.name.lowercased()
                    if !generatedStronglyTypedExtensions.contains(className) {
                        generatedStronglyTypedExtensions.insert(className)

                        if verbose {
                            print("Processing standard class '\(standardClass.name)' with \(standardClass.elements.count) elements:")
                        }
                        code += generateStronglyTypedExtension(standardClass, suite: nil)
                    }
                }
            }
        }

        return code
    }

    private func generateStronglyTypedExtension(_ sdefClass: SDEFClass, suite: SDEFSuite?) -> String {
        var className = sdefClass.name.swiftClassName
        // If the class name conflicts with the namespace name, add "Protocol" suffix
        if className == baseName {
            className = "\(className)Protocol"
        }
        let protocolName = "\(baseName).\(className)"

        var code = """

        /// Strongly typed accessors for \(sdefClass.name)
        public extension \(protocolName) {
        """

        // Generate strongly typed property wrappers for non-primitive properties
        for property in sdefClass.properties {
            // Skip list properties (handled separately below)
            guard !property.type.isList else { continue }

            let swiftType = swiftType(for: property.type)
            let needsPropertyWrapper = !basicSwiftTypes.contains(swiftType)

            if needsPropertyWrapper {
                // Use cocoa key if available, otherwise use the property name
                let propertyName = if let cocoaKey = property.cocoaKey {
                    cocoaKey.escapedReservedKeyword
                } else {
                    property.name.swiftPropertyName
                }

                // Use the property code for method names to avoid conflicts
                // Use both code and property name to ensure uniqueness
                let codeBaseName = property.code.swiftClassName
                let nameBaseName = property.name.swiftClassName.replacingOccurrences(of: " ", with: "")
                let methodBaseName = "\(codeBaseName)\(nameBaseName)"

                // Determine the type name with proper namespace
                let typeName = if swiftType == baseName || model.suites.flatMap({ $0.classes }).contains(where: { $0.name.swiftClassName == swiftType }) {
                    // If the type conflicts with namespace or is a class in our model, add namespace
                    if swiftType == baseName {
                        "\(baseName).\(swiftType)Protocol"
                    } else {
                        "\(baseName).\(swiftType)"
                    }
                } else {
                    swiftType
                }

                if let description = property.description {
                    code += "\n    /// \(description.capitalisedFirstLetter)"
                }

                if property.access == "r" {
                    // Read-only property
                    code += """

                    @inlinable var \(propertyName): \(typeName)! {
                        get { get\(methodBaseName)?() }
                    }
                """
                } else if property.access == "w" {
                    // Write-only property
                    let setterCall = if property.type.isOptional {
                        // If the setter accepts an optional, pass newValue directly
                        "set\(methodBaseName)?(newValue)"
                    } else {
                        // If the setter expects non-optional, unwrap first
                        "if let newValue { set\(methodBaseName)?(newValue) }"
                    }
                    code += """

                    @inlinable var \(propertyName): \(typeName)! {
                        set { \(setterCall) }
                    }
                """
                } else {
                    // Read-write property
                    let setterCall = if property.type.isOptional {
                        // If the setter accepts an optional, pass newValue directly
                        "set\(methodBaseName)?(newValue)"
                    } else {
                        // If the setter expects non-optional, unwrap first
                        "if let newValue { set\(methodBaseName)?(newValue) }"
                    }
                    code += """

                    @inlinable var \(propertyName): \(typeName)! {
                        get { get\(methodBaseName)?() }
                        set { \(setterCall) }
                    }
                """
                }
            }
        }

        // Generate strongly typed accessors for element arrays
        for element in sdefClass.elements {
            // Look up the class to get its plural name and generate typed accessor
            // Check both regular classes and standard classes
            let allClasses = model.suites.flatMap { $0.classes } + model.standardClasses
            let elementClass = allClasses.first { $0.name == element.type }

            // Only generate strongly typed accessor if the element type has a corresponding class definition
            guard elementClass != nil else {
                if verbose {
                    print("Skipping strongly typed accessor for \(element.type) - no corresponding class definition found")
                }
                continue
            }

            var methodName: String
            var pluralPropertyName: String

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name
                methodName = pluralName.swiftMethodName
                pluralPropertyName = pluralName.swiftMethodName
            } else {
                // Fallback: use the type name + "s"
                let pluralForm = element.type + "s"
                methodName = pluralForm.swiftMethodName
                pluralPropertyName = pluralForm.swiftMethodName
            }

            var elementClassName = element.type.swiftClassName
            // If the element class name conflicts with the namespace name, add "Protocol" suffix
            if elementClassName == baseName {
                elementClassName = "\(elementClassName)Protocol"
            }
            let elementTypeName = "\(baseName).\(elementClassName)"
            let untypedMethodName = "untyped" + methodName.capitalisedFirstLetter

            code += """

                /// Strongly typed accessor for \(element.type) elements
                var \(pluralPropertyName): [\(elementTypeName)] {
                    \(untypedMethodName)?() as? [\(elementTypeName)] ?? []
                }
            """
        }

        // Generate strongly typed accessors for list properties
        for property in sdefClass.properties {
            guard property.type.isList else { continue }

            let basePropertyName = if let cocoaKey = property.cocoaKey {
                cocoaKey.escapedReservedKeyword
            } else {
                property.name.swiftPropertyName
            }

            // The untyped property name must match the protocol property name (which uses original SDEF name)
            let protocolPropertyName = property.name.swiftPropertyName
            let untypedPropertyName = "untyped" + protocolPropertyName.capitalisedFirstLetter
            let baseTypeName = swiftUnprefixedTypeName(property.type.baseType)

            // Check if this is an enum type
            let allEnumNames = model.suites.flatMap { $0.enumerations }.map { $0.name.swiftClassName }
            let isEnumType = allEnumNames.contains(baseTypeName)

            if isEnumType {
                // For enum arrays, convert from SBElementArray using raw values
                let enumTypeName = "\(baseName).\(baseTypeName)"
                code += """

                    /// Strongly typed accessor for \(property.name)
                    var \(basePropertyName): [\(enumTypeName)] {
                        guard let untypedArray = \(untypedPropertyName) as? [AEKeyword] else { return [] }
                        return untypedArray.compactMap { \(enumTypeName)(rawValue: $0) }
                    }
                """
            } else {
                // For protocol/class arrays, simple cast should work
                // Only prefix with namespace for class types, not basic types
                let basicTypes = ["String", "Int", "Double", "Bool", "Date", "URL", "[String: Any]", "Any", "NSNull", "NSRect", "NSNumber", "NSPoint", "NSSize", "SBObject", "SBElementArray", "NSData"]
                let typeName = if basicTypes.contains(baseTypeName) {
                    baseTypeName
                } else {
                    // If the class name conflicts with the namespace name, add "Protocol" suffix
                    if baseTypeName == baseName {
                        "\(baseName).\(baseTypeName)Protocol"
                    } else {
                        "\(baseName).\(baseTypeName)"
                    }
                }

                code += """

                    /// Strongly typed accessor for \(property.name)
                    var \(basePropertyName): [\(typeName)] {
                        \(untypedPropertyName) as? [\(typeName)] ?? []
                    }
                """
            }
        }

        // Also generate property aliases based on Objective-C names
        code += generatePropertyAliases(sdefClass)

        code += """

        }

        """

        return code
    }

    private func generatePropertyAliases(_ sdefClass: SDEFClass) -> String {
        var code = ""

        // Generate aliases for properties where Cocoa key differs from original property name
        for property in sdefClass.properties {
            guard let cocoaKey = property.cocoaKey else { continue }

            // Generate alias from Swift idiomatic name to Objective-C property name
            // Protocol property uses objcPropertyName, alias provides swiftPropertyName
            let objcPropertyName = property.name.swiftPropertyName  // e.g., "passwordProtected"
            let swiftPropertyName = cocoaKey.escapedReservedKeyword  // e.g., "isPasswordProtected"

            // Skip if they're the same (no alias needed)
            guard objcPropertyName != swiftPropertyName else { continue }

            // Skip if this is a non-primitive type (already handled in property wrapper generation)
            let swiftType = swiftType(for: property.type)
            if !basicSwiftTypes.contains(swiftType) && !property.type.isList {
                // Non-primitive type - already has a property wrapper generated
                continue
            }

            // Check if the alias name would conflict with existing protocol properties
            // by looking for properties with the same name across all classes
            let aliasNameConflicts = model.suites.flatMap { $0.classes }.contains { otherClass in
                otherClass.properties.contains { otherProperty in
                    otherProperty.name.swiftPropertyName == swiftPropertyName
                }
            }

            // Skip generating the alias if it would conflict with a protocol property
            if aliasNameConflicts {
                if verbose {
                    print("Skipping alias '\(swiftPropertyName)' for '\(objcPropertyName)' in \(sdefClass.name) to avoid protocol property conflict")
                }
                continue
            }

            // For property aliases in extensions, we need to use the correct type references
            let baseTypeName = swiftUnprefixedTypeName(property.type.baseType)

            // Only prefix with namespace for class types, not basic types
            var aliasSwiftType: String
            if extendedBasicSwiftTypes.contains(baseTypeName) {
                aliasSwiftType = baseTypeName
            } else {
                // If the class name conflicts with the namespace name, add "Protocol" suffix
                if baseTypeName == baseName {
                    aliasSwiftType = "\(baseName).\(baseTypeName)Protocol"
                } else {
                    aliasSwiftType = "\(baseName).\(baseTypeName)"
                }
            }

            // Skip list properties - they already have strongly typed accessors generated elsewhere
            // that provide the Swift idiomatic names
            if property.type.isList {
                continue
            } else {
                // Generate getter/setter to match the exact protocol property type
                // The protocol property defines the expected return type, alias should match exactly
                let protocolPropertyType = swiftNamespacedType(for: property.type)

                // For non-optional protocol types, provide sensible defaults if underlying property might be nil
                if !protocolPropertyType.hasSuffix("?") {
                    let defaultValue = switch aliasSwiftType {
                    case "String":
                        "\(objcPropertyName) ?? \"\""
                    case "Int":
                        "\(objcPropertyName) ?? 0"
                    case "Double":
                        "\(objcPropertyName) ?? 0.0"
                    case "Bool":
                        "\(objcPropertyName) ?? false"
                    case "URL":
                        "\(objcPropertyName) ?? URL(fileURLWithPath: \"\")"
                    case "Date":
                        "\(objcPropertyName) ?? Date()"
                    case "NSNumber":
                        "\(objcPropertyName) ?? NSNumber(value: 0)"
                    default:
                        // For enum and complex types, check if we can provide a reasonable default
                        if aliasSwiftType.contains(".") {
                            // For complex types, use implicitly unwrapped optional to avoid crashes
                            // This allows users to check for nil if needed while maintaining type compatibility
                            objcPropertyName
                        } else {
                            "\(objcPropertyName) ?? \(aliasSwiftType)()"
                        }
                    }

                    // For complex types that could be nil, use implicitly unwrapped optional return type
                    let returnType = if aliasSwiftType.contains(".") && defaultValue == objcPropertyName {
                        "\(aliasSwiftType)!"
                    } else {
                        aliasSwiftType
                    }

                    code += """

                        /// Swift idiomatic alias for \(objcPropertyName)
                        var \(swiftPropertyName): \(returnType) { \(defaultValue) }
                    """
                } else {
                    // Protocol type is optional, alias can be optional too
                    code += """

                        /// Swift idiomatic alias for \(objcPropertyName)
                        var \(swiftPropertyName): \(aliasSwiftType) { \(objcPropertyName) }
                    """
                }
            }
        }

        return code
    }

    /// Generates a public enum containing all scripting class names from the SDEF.
    ///
    /// This method creates a CaseIterable, RawRepresentable enum that encompasses all
    /// scripting class names found in the SDEF file, including both regular classes
    /// and class extensions. The enum cases are generated using a transformation
    /// similar to the Python reference implementation, converting class names to
    /// proper Swift enum case names.
    ///
    /// - Returns: Swift code for the class names enumeration
    // MARK: - Namespace Methods

    private func generateNamespacedStandardEnums() -> String {
        // Check if we already have a SaveOptions or similar enum in the SDEF
        let hasExistingSaveOptions = model.suites.contains { suite in
            suite.enumerations.contains { enumeration in
                let enumName = enumeration.name.swiftClassName
                return enumName.lowercased().contains("saveoptions") ||
                enumName.lowercased() == "savo" ||
                enumeration.name.lowercased().contains("save options")
            }
        }

        if hasExistingSaveOptions {
            // Don't generate the standard SaveOptions if one already exists
            return ""
        }

        return """

            // MARK: - Save Options

            /// Standard save options for dialogs
            @objc public enum SaveOptions: AEKeyword, Sendable {
                case yes = 0x79657320  // 'yes '
                case no = 0x6e6f2020   // 'no  '
                case ask = 0x61736b20  // 'ask '
            }

        """
    }

    private func generateNamespacedTypeAliases() -> String {
        var aliases = """

            // MARK: - Type Aliases

        """

        // Don't generate Application typealias when application protocol exists
        // The application protocol is generated from CocoaStandard.sdef for most applications
        // Creating both a typealias and protocol with the same name causes naming conflicts

        aliases += """
            public typealias Object = SBObject
            public typealias ElementArray = SBElementArray

            // MARK: - Common Value Types
            /// Represents a color value
            public typealias Color = NSColor
            /// Represents an RGB color value
            public typealias RGBColor = NSColor
            /// Represents a TIFF picture
            public typealias TIFFPicture = NSImage
            /// Represents a TIFF image
            public typealias TIFFImage = NSImage

        """
        return aliases
    }

    private func generateNamespacedClassNamesEnum() -> String {
        var code = """

            // MARK: - Scripting Class Names

            /// An enumeration of all scripting class names defined in the SDEF.
            ///
            /// These string constants can be used when working with the Scripting Bridge
            /// to reference specific scriptable classes by name.
            public enum ClassNames {
        """

        // Collect all class names
        var classNames: Set<String> = []

        // Add standard classes
        for standardClass in model.standardClasses {
            classNames.insert(standardClass.name)
        }

        // Add regular classes
        for suite in model.suites {
            for sdefClass in suite.classes {
                classNames.insert(sdefClass.name)
            }
        }

        // Sort for consistent output
        let sortedNames = classNames.sorted()

        for className in sortedNames {
            let caseName = className.swiftPropertyName.replacingOccurrences(of: " ", with: "")
            let escapedName = caseName.escapedReservedKeyword
            code += "\n        public static let \(escapedName) = \"\(className)\""
        }

        code += "\n    }\n"
        return code
    }

    private func generateNamespacedEnumeration(_ enumeration: SDEFEnumeration) -> String {
        let enumName = enumeration.name.swiftClassName

        var code = """

            // MARK: - \(enumeration.name)

        """

        if let description = enumeration.description {
            code += "    /// \(description.capitalisedFirstLetter)\n"
        }

        code += "    @objc public enum \(enumName): AEKeyword, Sendable {\n"

        // Track used raw values and their corresponding case names
        var usedRawValues: [String: String] = [:]
        var aliasProperties: [String] = []

        for enumerator in enumeration.enumerators {
            if let description = enumerator.description {
                code += "        /// \(description.capitalisedFirstLetter)\n"
            }

            let caseName = enumerator.name.swiftCaseName
            let codeValue = enumerator.code.formattedEnumeratorCode

            // Check if we've already used this raw value
            if let existingCaseName = usedRawValues[codeValue] {
                // Create an alias property instead of a duplicate case
                if verbose {
                    print("Creating alias \(caseName) -> \(existingCaseName) for duplicate raw value \(codeValue) in \(enumName)")
                }
                aliasProperties.append("        /// Alias for \(existingCaseName)")
                aliasProperties.append("        public static let \(caseName): \(enumName) = .\(existingCaseName)")
            } else {
                // This is a new raw value, create the actual case
                usedRawValues[codeValue] = caseName
                code += "        case \(caseName) = \(codeValue)\n"
            }
        }

        // Add alias properties after the cases
        if !aliasProperties.isEmpty {
            code += "\n        // MARK: - Aliases for duplicate raw values\n"
            for aliasProperty in aliasProperties {
                code += "\(aliasProperty)\n"
            }
        }

        code += "    }\n"

        return code
    }

    private func generatePrefixedTypealiasesSection() -> String {
        var code = """

        // MARK: - Prefixed Type Aliases (for backward compatibility)

        """

        // Check if the SDEF model defines an Application class
        let hasApplicationClass = model.suites.contains { suite in
            suite.classes.contains { sdefClass in
                sdefClass.name.lowercased() == "application"
            }
        }

        if !hasApplicationClass {
            code += "public typealias \(baseName)Application = \(baseName).Application\n"
        }

        code += """
        public typealias \(baseName)Object = \(baseName).Object
        public typealias \(baseName)ElementArray = \(baseName).ElementArray

        """

        // Check if we should generate SaveOptions typealias
        let hasExistingSaveOptions = model.suites.contains { suite in
            suite.enumerations.contains { enumeration in
                let enumName = enumeration.name.swiftClassName
                return enumName.lowercased().contains("saveoptions") ||
                enumName.lowercased() == "savo" ||
                enumeration.name.lowercased().contains("save options")
            }
        }

        if !hasExistingSaveOptions {
            code += "public typealias \(baseName)SaveOptions = \(baseName).SaveOptions\n"
        }

        code += "\n"

        // Enumerations - avoid duplicates
        var generatedTypealiases = Set<String>()
        for suite in model.suites {
            for enumeration in suite.enumerations {
                let enumName = enumeration.name.swiftClassName
                let typealiasName = "\(baseName)\(enumName)"
                if !generatedTypealiases.contains(typealiasName) {
                    code += "public typealias \(typealiasName) = \(baseName).\(enumName)\n"
                    generatedTypealiases.insert(typealiasName)
                }
            }
        }

        return code + "\n"
    }

    private func generateFlatTypealiasesSection() -> String {
        var code = """

        // MARK: - Flat Type Aliases (for use as a separate module)

        """

        // Check if the SDEF model defines an Application class
        let hasApplicationClass = model.suites.contains { suite in
            suite.classes.contains { sdefClass in
                sdefClass.name.lowercased() == "application"
            }
        }

        if !hasApplicationClass {
            code += "public typealias Application = \(baseName).Application\n"
        }

        code += """
        public typealias Object = \(baseName).Object
        public typealias ElementArray = \(baseName).ElementArray

        """

        // Check if we should generate SaveOptions typealias
        let hasExistingSaveOptions = model.suites.contains { suite in
            suite.enumerations.contains { enumeration in
                let enumName = enumeration.name.swiftClassName
                return enumName.lowercased().contains("saveoptions") ||
                enumName.lowercased() == "savo" ||
                enumeration.name.lowercased().contains("save options")
            }
        }

        if !hasExistingSaveOptions {
            code += "public typealias SaveOptions = \(baseName).SaveOptions\n"
        }

        code += "\n"

        // Enumerations - avoid duplicates
        var generatedTypealiases = Set<String>()
        for suite in model.suites {
            for enumeration in suite.enumerations {
                let enumName = enumeration.name.swiftClassName
                if !generatedTypealiases.contains(enumName) {
                    code += "public typealias \(enumName) = \(baseName).\(enumName)\n"
                    generatedTypealiases.insert(enumName)
                }
            }
        }

        return code + "\n"
    }

    private func generateClassNamesEnum() -> String {
        var classNames = Set<String>()

        // Collect all class names (parser already filtered hidden classes if needed)
        for suite in model.suites {
            for sdefClass in suite.classes {
                classNames.insert(sdefClass.name)
            }

            // Also collect class extension names
            for classExtension in suite.classExtensions {
                classNames.insert(classExtension.extends)
            }
        }

        // Sort names for consistent output
        let sortedNames = classNames.sorted()

        var code = """

        /// An enumeration of all scripting class names available in this application.
        ///
        /// This enum provides a type-safe way to reference all scriptable classes defined
        /// in the application's scripting dictionary. Each case corresponds to a class
        /// that can be accessed through the Scripting Bridge framework.
        public enum \(baseName)ScriptingClassNames: String, CaseIterable {

        """

        for name in sortedNames {
            let caseName = name.asEnumCase
            code += "    case \(caseName) = \"\(name)\"\n"
        }

        code += "}\n\n"

        return code
    }
}
