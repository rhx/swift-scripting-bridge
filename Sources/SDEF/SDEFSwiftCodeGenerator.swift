//
// SDEFSwiftCodeGenerator.swift
// SDEF
//
// Created by Rene Hexel on 1/06/2024.
// Copyright Â© 2024, 2025 Rene Hexel. All rights reserved.
//
import Foundation
import SwiftSyntax
import SwiftSyntaxBuilder

/// A code generator that produces Swift Scripting Bridge code from parsed SDEF models.
///
/// The `SDEFSwiftCodeGenerator` transforms structured SDEF data into clean, type-safe Swift code
/// that provides interfaces for controlling scriptable macOS applications through the Scripting
/// Bridge framework. The generator handles proper Swift naming conventions, type mapping, and
/// protocol generation to create idiomatic Swift code from Apple Event definitions.
///
/// The generated code includes protocols for each scriptable class, enumerations for constant
/// values, type aliases for common Scripting Bridge types, and extension methods that provide
/// a complete Swift interface to the application's scripting capabilities.
public final class SDEFSwiftCodeGenerator {
    private let model: SDEFModel
    private let baseName: String
    private let shouldGenerateClassNamesEnum: Bool
    private let shouldGenerateStronglyTypedExtensions: Bool
    private let isIncludedFile: Bool
    private let verbose: Bool

    /// Creates a new Swift code generator with the specified configuration.
    ///
    /// The generator uses the provided SDEF model to create comprehensive Swift code that
    /// mirrors the application's scripting interface. The basename parameter determines
    /// the prefix used for all generated types, ensuring they don't conflict with other
    /// generated code in the same project.
    ///
    /// - Parameters:
    ///   - model: The parsed SDEF model containing all scripting definitions
    ///   - basename: The prefix to use for all generated Swift types
    ///   - shouldGenerateClassNamesEnum: Whether to generate an enum containing all scripting class names
    ///   - shouldGenerateStronglyTypedExtensions: Whether to generate strongly typed accessor extensions
    ///   - isIncludedFile: Whether this is an included file (skips foundation protocols)
    ///   - verbose: Whether to enable detailed logging during code generation
    public init(model: SDEFModel, basename: String, shouldGenerateClassNamesEnum: Bool, shouldGenerateStronglyTypedExtensions: Bool, isIncludedFile: Bool = false, verbose: Bool) {
        self.model = model
        self.baseName = basename
        self.shouldGenerateClassNamesEnum = shouldGenerateClassNamesEnum
        self.shouldGenerateStronglyTypedExtensions = shouldGenerateStronglyTypedExtensions
        self.isIncludedFile = isIncludedFile
        self.verbose = verbose
    }

    /// Generates complete Swift source code from the SDEF model.
    ///
    /// This method produces a complete Swift source file that includes all necessary imports,
    /// type definitions, protocols, and extensions needed to interact with the scriptable
    /// application. The generated code follows Swift best practices and provides type-safe
    /// interfaces that mirror the application's Apple Event scripting capabilities.
    ///
    /// The generation process creates several components: standard protocol definitions for
    /// generic scripting methods, enumerations for constant values, protocols for each
    /// scriptable class with their properties and methods, and extensions that conform
    /// Scripting Bridge types to these protocols.
    ///
    /// - Returns: A complete Swift source code string ready to be written to a file
    /// - Throws: `SDEFCodeGenerationError` if the model contains invalid or unsupported definitions
    public func generateCode() throws -> String {
        var code = """
        //
        // \(baseName).swift
        // Generated by sdef2swift
        //
        import Foundation
        import ScriptingBridge
        import AppKit

        """

        // Generate foundation protocols - always prefixed to avoid conflicts between different SDEF files
        code += """

        /// Protocol for ScriptingBridge Objects.
        ///
        /// This protocol defines the basic functionality for ScriptingBridge objects.
        @objc public protocol \(baseName)SBObjectProtocol: NSObjectProtocol {
            func get() -> Any!
        }
        extension SBObject: \(baseName)SBObjectProtocol {}

        /// Protocol for ScriptingBridge Applications.
        ///
        /// This protocol defines the basic functionality for ScriptingBridge applications,
        /// including standard Apple Event commands that most applications support.
        @objc public protocol \(baseName)SBApplicationProtocol: \(baseName)SBObjectProtocol {
            // MARK: - Core Application Methods

            /// Activate the application, bringing it to the foreground.
            func activate()

            /// The application's delegate for handling Scripting Bridge events.
            var delegate: SBApplicationDelegate! { get set }

            /// Whether the application is currently running.
            var isRunning: Bool { get }

            // MARK: - Standard Suite Commands

            /// Open the specified object(s).
            /// - Parameters:
            ///   - objects: List of objects to open
            ///   - using: The application file to open the object with (optional)
            ///   - withProperties: Initial values for properties (optional)
            @objc optional func open(_ objects: Any!, using: Any?, withProperties: [String: Any]?)

            /// Print the specified object(s).
            /// - Parameters:
            ///   - objects: List of objects to print
            ///   - withProperties: Optional properties for the print command
            @objc optional func print(_ objects: Any!, withProperties: [String: Any]?)

            /// Quit the application.
            @objc optional func quit()

            /// Close the specified object.
            /// - Parameter object: The object to close
            @objc optional func close(_ object: Any!)

            /// Return the number of elements of a particular class within an object.
            /// - Parameters:
            ///   - object: The object whose elements are to be counted
            ///   - each: The class of elements to count
            /// - Returns: The number of elements
            @objc optional func count(_ object: Any!, each: Any!) -> Int

            /// Return the size in bytes of an object.
            /// - Parameters:
            ///   - object: The object whose data size is to be returned
            ///   - as: The data type for which the size is calculated (optional)
            /// - Returns: The size of the object in bytes
            @objc optional func dataSize(_ object: Any!, as: Any?) -> Int

            /// Move an item from its container to the trash.
            /// - Parameter object: The item to delete
            /// - Returns: The item that was just deleted
            @objc optional func delete(_ object: Any!) -> Any!

            /// Duplicate one or more object(s).
            /// - Parameters:
            ///   - objects: The object(s) to duplicate
            ///   - to: The new location for the object(s) (optional)
            ///   - replacing: Whether to replace items with the same name (optional)
            ///   - routingSuppressed: Whether to suppress autorouting (optional)
            ///   - exactCopy: Whether to copy permissions/ownership as is (optional)
            /// - Returns: The duplicated object(s)
            @objc optional func duplicate(_ objects: Any!, to: Any?, replacing: Bool, routingSuppressed: Bool, exactCopy: Bool) -> Any!

            /// Verify if an object exists.
            /// - Parameter object: The object in question
            /// - Returns: True if it exists, false if not
            @objc optional func exists(_ object: Any!) -> Bool

            /// Make a new element.
            /// - Parameters:
            ///   - new: The class of the new element
            ///   - at: The location at which to insert the element
            ///   - to: When creating an alias, the original item (optional)
            ///   - withProperties: Initial values for properties (optional)
            /// - Returns: The new object(s)
            @objc optional func make(new: Any!, at: Any!, to: Any?, withProperties: [String: Any]?) -> Any!

            /// Move object(s) to a new location.
            /// - Parameters:
            ///   - objects: The object(s) to move
            ///   - to: The new location for the object(s)
            ///   - replacing: Whether to replace items with the same name (optional)
            ///   - positionedAt: List of positions for destination items (optional)
            ///   - routingSuppressed: Whether to suppress autorouting (optional)
            /// - Returns: The object(s) after they have been moved
            @objc optional func move(_ objects: Any!, to: Any!, replacing: Bool, positionedAt: [Any]?, routingSuppressed: Bool) -> Any!

            /// Select the specified object(s).
            /// - Parameter object: The object to select
            @objc optional func select(_ object: Any!)
        }
        extension SBApplication: \(baseName)SBApplicationProtocol {}

        """

        // Generate type aliases for common ScriptingBridge types
        code += generateTypeAliases()

        // Generate standard protocols and enums first
        code += generateApplicationProtocol()

        // Generate class names enum if requested
        if shouldGenerateClassNamesEnum {
            code += generateClassNamesEnum()
        }

        // Generate enumerations
        for suite in model.suites {
            for enumeration in suite.enumerations {
                code += generateEnumeration(enumeration)
            }
        }

        // Generate protocols for standard classes that haven't been merged
        let mergedClassNames = Set(model.suites.flatMap { $0.classes }.map { $0.name })
        for standardClass in model.standardClasses {
            // Only generate if this standard class hasn't been merged into a regular class
            if !mergedClassNames.contains(standardClass.name) {
                code += generateClassProtocol(standardClass, suite: SDEFSuite(name: "Standard", code: "std", description: "Standard classes", classes: [], enumerations: [], commands: [], classExtensions: []))
            }
        }

        // Generate protocols for classes
        for suite in model.suites {
            for sdefClass in suite.classes {
                code += generateClassProtocol(sdefClass, suite: suite)
            }

            // Generate protocols for class extensions
            for classExtension in suite.classExtensions {
                code += generateClassExtensionProtocol(classExtension, suite: suite)
            }
        }

        // Generate strongly typed extensions if requested
        if shouldGenerateStronglyTypedExtensions {
            code += generateStronglyTypedExtensions()
        }

        // Generate SBApplication extension
        code += generateSBApplicationExtension()

        return code
    }

    private func generateTypeAliases() -> String {
        // Don't generate typealias for Application if there's also an Application protocol
        let hasApplicationClass = model.suites.flatMap { $0.classes }.contains { $0.name.lowercased() == "application" }

        var aliases = """

// MARK: - Type Aliases

"""

        if !hasApplicationClass {
            aliases += "public typealias \(baseName)Application = SBApplication\n"
        }

        aliases += """
public typealias \(baseName)Object = SBObject
public typealias \(baseName)ElementArray = SBElementArray

"""
        return aliases
    }

    private func generateEnumeration(_ enumeration: SDEFEnumeration) -> String {
        let enumName = "\(baseName)\(enumeration.name.capitalizingFirstLetter().replacingOccurrences(of: " ", with: "").replacingOccurrences(of: "-", with: ""))"

        var code = """

        // MARK: - \(enumeration.name)

        """

        if let description = enumeration.description {
            code += "/// \(description.capitalizingFirstLetter())\n"
        }

        code += "@objc public enum \(enumName): AEKeyword {\n"

        for enumerator in enumeration.enumerators {
            if let description = enumerator.description {
                code += "    /// \(description.capitalizingFirstLetter())\n"
            }

            let caseName = swiftCaseName(enumerator.name)
            let codeValue = formatEnumeratorCode(enumerator.code)
            code += "    case \(caseName) = \(codeValue)\n"
        }

        code += "}\n"

        return code
    }

    private func generateClassProtocol(_ sdefClass: SDEFClass, suite: SDEFSuite) -> String {
        let protocolName = "\(baseName)\(swiftClassName(sdefClass.name))"

        var code = """

        // MARK: - \(sdefClass.name)

        """

        if let description = sdefClass.description {
            code += "/// \(description.capitalizingFirstLetter())\n"
        }

        var inheritanceList: [String]

        // Application classes should inherit from SBApplicationProtocol, others from SBObjectProtocol
        // Always use prefixed versions to avoid conflicts between different SDEF files
        if sdefClass.name.lowercased() == "application" {
            inheritanceList = ["\(baseName)SBApplicationProtocol"]
        } else {
            inheritanceList = ["\(baseName)SBObjectProtocol"]
        }

        // Add GenericMethods for standard classes
        if ["window", "document", "application"].contains(sdefClass.name.lowercased()) {
            inheritanceList.append("\(baseName)GenericMethods")
        }

        if let inherits = sdefClass.inherits {
            let cleanInherits = swiftClassName(inherits)

            // Check if the inherited class actually exists in the model
            let allClasses = model.suites.flatMap { $0.classes } + model.standardClasses
            let inheritsClassExists = allClasses.contains { $0.name.lowercased() == inherits.lowercased() }

            if inheritsClassExists {
                inheritanceList.append("\(baseName)\(cleanInherits)")
            } else if verbose {
                print("Warning: Class '\(sdefClass.name)' inherits from '\(inherits)' but '\(inherits)' is not defined in the SDEF model")
            }
        }

        code += "@objc public protocol \(protocolName): \(inheritanceList.joined(separator: ", ")) {\n"

        // Generate properties
        for property in sdefClass.properties {
            code += generateProperty(property)
        }

        // Generate element arrays
        for element in sdefClass.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
                ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "    /// Array of \(element.type) objects - \(description.lowercaseFirstLetter())\n"
            }

            code += "    @objc optional func \(methodName)() -> SBElementArray\n"
        }

        // Generate setter methods only for write-only properties
        for property in sdefClass.properties {
            if property.access == "w" { // Write-only properties need explicit setter methods
                let propertyName = if let cocoaKey = property.cocoaKey {
                    // Cocoa keys are already in proper Swift naming convention
                    escapeReservedKeyword(cocoaKey)
                } else {
                    swiftPropertyName(property.name)
                }
                let swiftType = swiftSetterParameterType(for: property.type)

                // Generate DocC comment for setter
                if let description = property.description {
                    let setterDescription = "Set \(description.lowercaseFirstLetter())"
                    code += "    /// \(setterDescription.capitalizingFirstLetter())\n"
                }

                // Fix setter naming for special cases
                let setterName = switch property.name.lowercased() {
                case "current tab":
                    "CurrentTab"
                case "url":
                    "URL"
                default:
                    swiftClassName(property.name)
                }

                code += "    @objc optional func set\(setterName)(_ \(propertyName): \(swiftType))\n"
            }
        }

        code += "}\n"

        // Generate extension - SBApplication for application classes, SBObject for others
        if sdefClass.name.lowercased() == "application" {
            code += """

            extension SBApplication: \(protocolName) {}

            """
        } else {
            code += """

            extension SBObject: \(protocolName) {}

            """
        }

        return code
    }

    private func generateClassExtensionProtocol(_ classExtension: SDEFClassExtension, suite: SDEFSuite) -> String {
        let baseTypeName = swiftClassName(classExtension.extends)
        let protocolName = "\(baseName)\(baseTypeName)"

        var code = """

        // MARK: - \(classExtension.extends) Extension

        @objc public protocol \(protocolName): SBObject {

        """

        // Generate properties
        for property in classExtension.properties {
            code += generateProperty(property)
        }

        // Generate element arrays
        for element in classExtension.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
                ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "    /// Array of \(element.type) objects - \(description.lowercaseFirstLetter())\n"
            }

            code += "    @objc optional func \(methodName)() -> SBElementArray\n"
        }

        code += "}\n"

        // Generate SBObject extension
        code += """

        extension SBObject: \(protocolName) {}

        """

        return code
    }

    private func generateProperty(_ property: SDEFProperty) -> String {
        var code = ""

        if let description = property.description {
            code += "    /// \(description.capitalizingFirstLetter())\n"
        }

        // Use cocoa key if available, otherwise use the property name
        let propertyName = if let cocoaKey = property.cocoaKey {
            // Cocoa keys are already in proper Swift naming convention (e.g., isShared)
            // Just escape reserved keywords if needed
            escapeReservedKeyword(cocoaKey)
        } else {
            swiftPropertyName(property.name)
        }
        let swiftType = swiftType(for: property.type)

        let accessors = switch property.access {
        case "r":
            " { get }"
        case "w":
            " { set }"
        default:
            " { get set }"
        }

        // If we're using a cocoa key that differs from the property name,
        // we need to specify the original name for Objective-C
        if let cocoaKey = property.cocoaKey, cocoaKey != property.name {
            let objcName = swiftPropertyName(property.name)
            code += "    @objc(\(objcName)) optional var \(propertyName): \(swiftType)\(accessors)\n"
        } else {
            code += "    @objc optional var \(propertyName): \(swiftType)\(accessors)\n"
        }

        return code
    }

    private func generateApplicationProtocol() -> String {
        // Always use prefixed base protocol to avoid conflicts between different SDEF files
        let applicationBaseProtocol = "\(baseName)SBApplicationProtocol"

        return """

        // MARK: - Save Options Enum

        @objc public enum \(baseName)SaveOptions: AEKeyword {
            case yes = 0x79657320  // 'yes '
            case no = 0x6e6f2020   // 'no  '
            case ask = 0x61736b20  // 'ask '
        }

        // MARK: - Generic Methods Protocol

        @objc public protocol \(baseName)GenericMethods {
            @objc optional func closeSaving(_ saving: \(baseName)SaveOptions, savingIn: URL?)
            @objc optional func saveIn(_ in_: URL?, as: Any?)
            @objc optional func printWithProperties(_ withProperties: [String: Any]?, printDialog: Bool)
            @objc optional func delete()
            @objc optional func duplicateTo(_ to: SBObject?, withProperties: [String: Any]?)
            @objc optional func moveTo(_ to: SBObject?)
        }

        // MARK: - Application Protocol

        @objc public protocol \(baseName)ApplicationProtocol: \(applicationBaseProtocol) {
            /// Array of document objects - A document.
            @objc optional func documents() -> SBElementArray
            /// Array of window objects - A window.
            @objc optional func windows() -> SBElementArray
        }

        """
    }

    private func generateSBApplicationExtension() -> String {
        return """

        extension SBApplication: \(baseName)ApplicationProtocol {}

        extension SBObject: \(baseName)GenericMethods {}

        """
    }

    // MARK: - Helper Methods

    private func swiftType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftTypeName(propertyType.baseType)

        if propertyType.isList {
            baseType = "[\(baseType)]"
        }

        // For @objc optional properties, never make types optional to avoid double optionals
        // The @objc optional already provides the optionality
        return baseType
    }

    private func swiftSetterParameterType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftTypeName(propertyType.baseType)

        if propertyType.isList {
            baseType = "[\(baseType)]"
        }

        // For setter method parameters, preserve optionality as it's separate from @objc optional
        if propertyType.isOptional {
            baseType += "?"
        }

        return baseType
    }

    private func swiftTypeName(_ objcType: String) -> String {
        switch objcType.lowercased() {
        case "text", "string":
            return "String"
        case "integer", "int":
            return "Int"
        case "real", "double":
            return "Double"
        case "boolean", "bool":
            return "Bool"
        case "date":
            return "Date"
        case "file", "alias":
            return "URL"
        case "record":
            return "[String: Any]"
        case "any":
            return "Any"
        case "missing value":
            return "NSNull"
        case "rectangle":
            return "NSRect"
        case "number":
            return "NSNumber"
        case "point":
            return "NSPoint"
        case "size":
            return "NSSize"
        case "specifier":
            return "SBObject"
        case "location specifier":
            return "SBObject"
        case "type":
            return "OSType"
        case "picture":
            return "NSImage"
        case "enum":
            return "OSType"
        case "double integer":
            return "Int64"
        default:
            // Assume it's a class name - clean up the name
            let cleanType = swiftClassName(objcType)
            return "\(baseName)\(cleanType)"
        }
    }

    private func swiftPropertyName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return escapeReservedKeyword(name) }

        // Process each word
        var processedWords: [String] = []

        for (index, word) in words.enumerated() {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if index == 0 {
                // First word should be lowercase, except for special cases
                if upperWord == "URL" || upperWord == "UUID" || upperWord == "ID" ||
                   upperWord == "HTTP" || upperWord == "HTTPS" || upperWord == "XML" ||
                   upperWord == "HTML" || upperWord == "PDF" || upperWord == "UI" ||
                   upperWord == "API" {
                    processedWords.append(cleanWord.lowercased())
                } else {
                    processedWords.append(cleanWord.lowercased())
                }
            } else if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
                      upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
                      upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
                      upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else {
                // Subsequent words should be capitalized
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        let result = processedWords.joined()
        return escapeReservedKeyword(result)
    }

    private func escapeReservedKeyword(_ name: String) -> String {
        let swiftKeywords = [
            "associatedtype", "class", "deinit", "enum", "extension", "fileprivate", "func",
            "import", "init", "inout", "internal", "let", "open", "operator", "private",
            "protocol", "public", "rethrows", "static", "struct", "subscript", "typealias",
            "var", "break", "case", "continue", "default", "defer", "do", "else", "fallthrough",
            "for", "guard", "if", "in", "repeat", "return", "switch", "where", "while",
            "as", "Any", "catch", "false", "is", "nil", "super", "self", "Self", "throw",
            "throws", "true", "try", "associativity", "convenience", "dynamic", "didSet",
            "final", "get", "infix", "indirect", "lazy", "left", "mutating", "none",
            "nonmutating", "optional", "override", "postfix", "precedence", "prefix",
            "Protocol", "required", "right", "set", "Type", "unowned", "weak", "willSet"
        ]

        if swiftKeywords.contains(name) {
            return "`\(name)`"
        }
        return name
    }

    private func swiftMethodName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return name }

        // Process each word
        var processedWords: [String] = []

        for (index, word) in words.enumerated() {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
               upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
               upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
               upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else if index == 0 {
                // First word should be lowercase
                processedWords.append(cleanWord.lowercased())
            } else {
                // Subsequent words should be capitalized
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        return processedWords.joined()
    }

    private func swiftClassName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return name }

        // Process each word by capitalizing first letter
        var processedWords: [String] = []

        for word in words {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
               upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
               upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
               upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else {
                // All words should be capitalized for type names
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        return processedWords.joined()
    }

    private func generateStronglyTypedExtensions() -> String {
        var code = """

        // MARK: - Strongly Typed Extensions

        """

        // For included files, only process classes from the main suites (not standard classes)
        // For main files, process all classes from main suites
        for suite in model.suites {
            for sdefClass in suite.classes {
                if !sdefClass.elements.isEmpty {
                    if verbose {
                        print("Processing class '\(sdefClass.name)' with \(sdefClass.elements.count) elements:")
                    }
                    code += generateStronglyTypedExtension(sdefClass, suite: suite)
                }
            }
        }

        // For main files only, process standard classes that have elements
        // but skip those that already have corresponding classes in the main suites
        if !isIncludedFile {
            let mainSuiteClassNames = Set(model.suites.flatMap { $0.classes }.map { $0.name.lowercased() })

            for standardClass in model.standardClasses {
                if !standardClass.elements.isEmpty {
                    // Skip standard classes that have corresponding classes in main suites
                    if mainSuiteClassNames.contains(standardClass.name.lowercased()) {
                        if verbose {
                            print("Skipping standard class '\(standardClass.name)' - already defined in main suites")
                        }
                        continue
                    }

                    if verbose {
                        print("Processing standard class '\(standardClass.name)' with \(standardClass.elements.count) elements:")
                    }
                    code += generateStronglyTypedExtension(standardClass, suite: nil)
                }
            }
        }

        return code
    }

    private func generateStronglyTypedExtension(_ sdefClass: SDEFClass, suite: SDEFSuite?) -> String {
        let protocolName = "\(baseName)\(swiftClassName(sdefClass.name))"

        var code = """

        /// Strongly typed accessors for \(sdefClass.name)
        public extension \(protocolName) {
        """

        for element in sdefClass.elements {
            // Look up the class to get its plural name and generate typed accessor
            // Check both regular classes and standard classes
            let allClasses = model.suites.flatMap { $0.classes } + model.standardClasses
            let elementClass = allClasses.first { $0.name == element.type }

            // Only generate strongly typed accessor if the element type has a corresponding class definition
            guard elementClass != nil else {
                if verbose {
                    print("Skipping strongly typed accessor for \(element.type) - no corresponding class definition found")
                }
                continue
            }

            var methodName: String
            var pluralPropertyName: String

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name
                methodName = swiftMethodName(pluralName)
                pluralPropertyName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s"
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
                pluralPropertyName = swiftMethodName(pluralForm)
            }

            let elementTypeName = "\(baseName)\(swiftClassName(element.type))"
            let prefixedPropertyName = baseName.lowercaseFirstLetter() + pluralPropertyName.capitalizingFirstLetter()

            code += """

                /// Strongly typed accessor for \(element.type) elements
                var \(prefixedPropertyName): [\(elementTypeName)] {
                    \(methodName)?() as? [\(elementTypeName)] ?? []
                }
            """
        }

        code += """

        }

        """

        return code
    }

    private func swiftCaseName(_ name: String) -> String {
        let cleaned = name
            .replacingOccurrences(of: " ", with: "")
            .replacingOccurrences(of: "-", with: "")
            .replacingOccurrences(of: "_", with: "")

        return cleaned.lowercaseFirstLetter()
    }

    private func formatEnumeratorCode(_ code: String) -> String {
        // Convert 4-character codes to proper format
        if code.count == 4 {
            let chars = Array(code)
            let formatted = chars.compactMap { char in
                guard let ascii = char.asciiValue else { return "00" }
                return String(format: "%02x", ascii)
            }.joined()
            return "0x\(formatted)"
        }
        // Handle other code formats
        if code.hasPrefix("0x") || code.allSatisfy({ $0.isHexDigit }) {
            return code.hasPrefix("0x") ? code : "0x\(code)"
        }
        return "'\(code)'"
    }

    /// Generates a public enum containing all scripting class names from the SDEF.
    ///
    /// This method creates a CaseIterable, RawRepresentable enum that encompasses all
    /// scripting class names found in the SDEF file, including both regular classes
    /// and class extensions. The enum cases are generated using a transformation
    /// similar to the Python reference implementation, converting class names to
    /// proper Swift enum case names.
    ///
    /// - Returns: Swift code for the class names enumeration
    private func generateClassNamesEnum() -> String {
        var classNames = Set<String>()

        // Collect all class names (parser already filtered hidden classes if needed)
        for suite in model.suites {
            for sdefClass in suite.classes {
                classNames.insert(sdefClass.name)
            }

            // Also collect class extension names
            for classExtension in suite.classExtensions {
                classNames.insert(classExtension.extends)
            }
        }

        // Sort names for consistent output
        let sortedNames = classNames.sorted()

        var code = """

        /// An enumeration of all scripting class names available in this application.
        ///
        /// This enum provides a type-safe way to reference all scriptable classes defined
        /// in the application's scripting dictionary. Each case corresponds to a class
        /// that can be accessed through the Scripting Bridge framework.
        public enum \(baseName)ScriptingClassNames: String, CaseIterable {

        """

        for name in sortedNames {
            let caseName = transformToEnumCase(name)
            code += "    case \(caseName) = \"\(name)\"\n"
        }

        code += "}\n\n"

        return code
    }

    /// Transforms a class name into a proper Swift enum case name.
    ///
    /// This method implements the same transformation logic as the Python reference,
    /// converting class names by removing quotes and hyphens, capitalizing words,
    /// and then converting to camelCase for the enum case.
    ///
    /// - Parameter name: The original class name from the SDEF
    /// - Returns: A properly formatted Swift enum case name
    private func transformToEnumCase(_ name: String) -> String {
        // Remove quotes and replace hyphens with spaces
        let transformed = name
            .replacingOccurrences(of: "\"", with: "")
            .replacingOccurrences(of: "-", with: " ")

        // Capitalize each word and remove spaces
        let words = transformed.components(separatedBy: " ")
        let capitalized = words.map { $0.capitalizingFirstLetter() }.joined()

        // Convert to camelCase (first letter lowercase)
        return capitalized.lowercaseFirstLetter()
    }
}

/// Errors that can occur during Swift code generation.
///
/// These errors indicate problems encountered while transforming SDEF model data
/// into Swift source code, such as unsupported type definitions or invalid
/// naming conventions that cannot be mapped to valid Swift identifiers.
public enum SDEFCodeGenerationError: Error {
    /// An unsupported SDEF type was encountered that cannot be mapped to Swift
    case unsupportedType(String)

    /// An invalid identifier name was found that cannot be converted to valid Swift
    case invalidIdentifier(String)

    /// A structural problem in the SDEF model prevents code generation
    case invalidModel(String)
}

extension SDEFCodeGenerationError: LocalizedError {
    /// A localised description of the code generation error.
    ///
    /// Provides detailed error messages that explain what went wrong during the
    /// Swift code generation process. These messages are designed to help developers
    /// understand and resolve issues with their SDEF files or generation configuration.
    ///
    /// - Returns: A descriptive error message suitable for display or logging
    public var errorDescription: String? {
        switch self {
        case .unsupportedType(let type):
            return "Unsupported SDEF type: \(type)"
        case .invalidIdentifier(let identifier):
            return "Invalid Swift identifier: \(identifier)"
        case .invalidModel(let message):
            return "Invalid SDEF model: \(message)"
        }
    }
}

// MARK: - String Extensions

extension String {
    /// Returns a copy of the string with the first character capitalised.
    ///
    /// This method converts the first character of the string to uppercase while
    /// leaving the rest of the string unchanged. It's commonly used for converting
    /// identifiers to proper Swift type names and method names.
    ///
    /// - Returns: A string with the first character capitalised
    func capitalizingFirstLetter() -> String {
        return prefix(1).uppercased() + dropFirst()
    }

    /// Returns a copy of the string with the first character in lowercase.
    ///
    /// This method converts the first character of the string to lowercase while
    /// preserving the case of all other characters. It's used for generating
    /// proper Swift property and variable names from SDEF identifiers.
    ///
    /// - Returns: A string with the first character in lowercase
    func lowercaseFirstLetter() -> String {
        return prefix(1).lowercased() + dropFirst()
    }
}
