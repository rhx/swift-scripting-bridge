//
// SDEFSwiftCodeGenerator.swift
// SDEF
//
// Created by Rene Hexel on 1/06/2024.
// Copyright Â© 2024, 2025 Rene Hexel. All rights reserved.
//
import Foundation
import SwiftSyntax
import SwiftSyntaxBuilder

/// A code generator that produces Swift Scripting Bridge code from parsed SDEF models.
///
/// The `SDEFSwiftCodeGenerator` transforms structured SDEF data into clean, type-safe Swift code
/// that provides interfaces for controlling scriptable macOS applications through the Scripting
/// Bridge framework. The generator handles proper Swift naming conventions, type mapping, and
/// protocol generation to create idiomatic Swift code from Apple Event definitions.
///
/// The generated code includes protocols for each scriptable class, enumerations for constant
/// values, type aliases for common Scripting Bridge types, and extension methods that provide
/// a complete Swift interface to the application's scripting capabilities.
public final class SDEFSwiftCodeGenerator {
    private let model: SDEFModel
    private let baseName: String
    private let shouldGenerateClassNamesEnum: Bool
    private let shouldGenerateStronglyTypedExtensions: Bool
    private let verbose: Bool

    /// Creates a new Swift code generator with the specified configuration.
    ///
    /// The generator uses the provided SDEF model to create comprehensive Swift code that
    /// mirrors the application's scripting interface. The basename parameter determines
    /// the prefix used for all generated types, ensuring they don't conflict with other
    /// generated code in the same project.
    ///
    /// - Parameters:
    ///   - model: The parsed SDEF model containing all scripting definitions
    ///   - basename: The prefix to use for all generated Swift types
    ///   - shouldGenerateClassNamesEnum: Whether to generate an enum containing all scripting class names
    ///   - shouldGenerateStronglyTypedExtensions: Whether to generate strongly typed accessor extensions
    ///   - verbose: Whether to enable detailed logging during code generation
    public init(model: SDEFModel, basename: String, shouldGenerateClassNamesEnum: Bool, shouldGenerateStronglyTypedExtensions: Bool, verbose: Bool) {
        self.model = model
        self.baseName = basename
        self.shouldGenerateClassNamesEnum = shouldGenerateClassNamesEnum
        self.shouldGenerateStronglyTypedExtensions = shouldGenerateStronglyTypedExtensions
        self.verbose = verbose
    }

    /// Generates complete Swift source code from the SDEF model.
    ///
    /// This method produces a complete Swift source file that includes all necessary imports,
    /// type definitions, protocols, and extensions needed to interact with the scriptable
    /// application. The generated code follows Swift best practices and provides type-safe
    /// interfaces that mirror the application's Apple Event scripting capabilities.
    ///
    /// The generation process creates several components: standard protocol definitions for
    /// generic scripting methods, enumerations for constant values, protocols for each
    /// scriptable class with their properties and methods, and extensions that conform
    /// Scripting Bridge types to these protocols.
    ///
    /// - Returns: A complete Swift source code string ready to be written to a file
    /// - Throws: `SDEFCodeGenerationError` if the model contains invalid or unsupported definitions
    public func generateCode() throws -> String {
        var code = """
        //
        // \(baseName).swift
        // Generated by sdef2swift
        //

        import Foundation
        import ScriptingBridge

        """

        // Generate type aliases for common ScriptingBridge types
        code += generateTypeAliases()

        // Generate standard protocols and enums first
        code += generateApplicationProtocol()

        // Generate class names enum if requested
        if shouldGenerateClassNamesEnum {
            code += generateClassNamesEnum()
        }

        // Generate enumerations
        for suite in model.suites {
            for enumeration in suite.enumerations {
                code += generateEnumeration(enumeration)
            }
        }

        // Generate protocols for classes
        for suite in model.suites {
            for sdefClass in suite.classes {
                code += generateClassProtocol(sdefClass, suite: suite)
            }

            // Generate protocols for class extensions
            for classExtension in suite.classExtensions {
                code += generateClassExtensionProtocol(classExtension, suite: suite)
            }
        }

        // Generate strongly typed extensions if requested
        if shouldGenerateStronglyTypedExtensions {
            code += generateStronglyTypedExtensions()
        }

        // Generate SBApplication extension
        code += generateSBApplicationExtension()

        return code
    }

    private func generateTypeAliases() -> String {
        return """

        // MARK: - Type Aliases

        public typealias \(baseName)Application = SBApplication
        public typealias \(baseName)Object = SBObject
        public typealias \(baseName)ElementArray = SBElementArray

        """
    }

    private func generateEnumeration(_ enumeration: SDEFEnumeration) -> String {
        let enumName = "\(baseName)\(enumeration.name.capitalizingFirstLetter().replacingOccurrences(of: " ", with: "").replacingOccurrences(of: "-", with: ""))"

        var code = """

        // MARK: - \(enumeration.name)

        """

        if let description = enumeration.description {
            code += "/// \(description.capitalizingFirstLetter())\n"
        }

        code += "@objc public enum \(enumName): AEKeyword {\n"

        for enumerator in enumeration.enumerators {
            if let description = enumerator.description {
                code += "    /// \(description.capitalizingFirstLetter())\n"
            }

            let caseName = swiftCaseName(enumerator.name)
            let codeValue = formatEnumeratorCode(enumerator.code)
            code += "    case \(caseName) = \(codeValue)\n"
        }

        code += "}\n"

        return code
    }

    private func generateClassProtocol(_ sdefClass: SDEFClass, suite: SDEFSuite) -> String {
        let protocolName = "\(baseName)\(swiftClassName(sdefClass.name))"

        var code = """

        // MARK: - \(sdefClass.name)

        """

        if let description = sdefClass.description {
            code += "/// \(description.capitalizingFirstLetter())\n"
        }

        var inheritanceList = ["SBObjectProtocol"]

        // Add GenericMethods for standard classes
        if ["window", "document", "application"].contains(sdefClass.name.lowercased()) {
            inheritanceList.append("\(baseName)GenericMethods")
        }

        if let inherits = sdefClass.inherits {
            let cleanInherits = swiftClassName(inherits)
            inheritanceList.append("\(baseName)\(cleanInherits)")
        }

        code += "@objc public protocol \(protocolName): \(inheritanceList.joined(separator: ", ")) {\n"

        // Generate properties
        for property in sdefClass.properties {
            code += generateProperty(property)
        }

        // Generate id() method for classes that have it
        if sdefClass.properties.contains(where: { $0.name == "id" }) {
            code += "    @objc optional func id() -> Int\n"
        }

        // Generate element arrays
        for element in sdefClass.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
            }

            code += "    @objc optional func \(methodName)() -> SBElementArray\n"
        }

        // Generate setter methods for writable properties
        for property in sdefClass.properties {
            if property.access != "r" { // Not read-only
                let propertyName = swiftPropertyName(property.name)
                let swiftType = swiftType(for: property.type)

                // Generate DocC comment for setter
                if let description = property.description {
                    let setterDescription = "Set \(description.lowercaseFirstLetter())"
                    code += "    /// \(setterDescription.capitalizingFirstLetter())\n"
                }

                // Fix setter naming for special cases
                let setterName = switch property.name.lowercased() {
                case "current tab":
                    "CurrentTab"
                case "url":
                    "URL"
                default:
                    swiftClassName(property.name)
                }

                code += "    @objc optional func set\(setterName)(_ \(propertyName): \(swiftType))\n"
            }
        }

        code += "}\n"

        // Generate SBObject extension
        code += """

        extension SBObject: \(protocolName) {}

        """

        return code
    }

    private func generateClassExtensionProtocol(_ classExtension: SDEFClassExtension, suite: SDEFSuite) -> String {
        let baseTypeName = swiftClassName(classExtension.extends)
        let protocolName = "\(baseName)\(baseTypeName)"

        var code = """

        // MARK: - \(classExtension.extends) Extension

        @objc public protocol \(protocolName): SBObject {

        """

        // Generate properties
        for property in classExtension.properties {
            code += generateProperty(property)
        }

        // Generate element arrays
        for element in classExtension.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
            }

            code += "    @objc optional func \(methodName)() -> SBElementArray\n"
        }

        code += "}\n"

        // Generate SBObject extension
        code += """

        extension SBObject: \(protocolName) {}

        """

        return code
    }

    private func generateProperty(_ property: SDEFProperty) -> String {
        var code = ""

        if let description = property.description {
            code += "    /// \(description.capitalizingFirstLetter())\n"
        }

        let propertyName = swiftPropertyName(property.name)
        let swiftType = swiftType(for: property.type)

        // Special handling for id property - make it a method
        if property.name == "id" {
            return "" // Skip generating property for id, it will be handled as a method
        }

        let readOnly = property.access == "r" ? " { get }" : " { get set }"

        code += "    @objc optional var \(propertyName): \(swiftType)\(readOnly)\n"

        return code
    }

    private func generateApplicationProtocol() -> String {
        return """

        // MARK: - Save Options Enum

        @objc public enum \(baseName)SaveOptions: AEKeyword {
            case yes = 0x79657320  // 'yes '
            case no = 0x6e6f2020   // 'no  '
            case ask = 0x61736b20  // 'ask '
        }

        // MARK: - Generic Methods Protocol

        @objc public protocol \(baseName)GenericMethods {
            @objc optional func closeSaving(_ saving: \(baseName)SaveOptions, savingIn: URL?)
            @objc optional func saveIn(_ in_: URL?, as: Any?)
            @objc optional func printWithProperties(_ withProperties: [String: Any]?, printDialog: Bool)
            @objc optional func delete()
            @objc optional func duplicateTo(_ to: SBObject?, withProperties: [String: Any]?)
            @objc optional func moveTo(_ to: SBObject?)
        }

        // MARK: - Application Protocol

        @objc public protocol \(baseName)ApplicationProtocol: SBApplicationProtocol {
            @objc optional func documents() -> SBElementArray
            @objc optional func windows() -> SBElementArray
        }

        """
    }

    private func generateSBApplicationExtension() -> String {
        return """
        extension SBApplication: \(baseName)ApplicationProtocol {}

        extension SBObject: \(baseName)GenericMethods {}

        """
    }

    // MARK: - Helper Methods

    private func swiftType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftTypeName(propertyType.baseType)

        if propertyType.isList {
            baseType = "[\(baseType)]"
        }

        if propertyType.isOptional {
            baseType += "?"
        }

        return baseType
    }

    private func swiftTypeName(_ objcType: String) -> String {
        switch objcType.lowercased() {
        case "text", "string":
            return "String"
        case "integer", "int":
            return "Int"
        case "real", "double":
            return "Double"
        case "boolean", "bool":
            return "Bool"
        case "date":
            return "Date"
        case "file", "alias":
            return "URL"
        case "record":
            return "[String: Any]"
        case "any":
            return "Any"
        case "missing value":
            return "NSNull"
        case "rectangle":
            return "NSRect"
        case "number":
            return "NSNumber"
        case "point":
            return "NSPoint"
        case "size":
            return "NSSize"
        default:
            // Assume it's a class name - clean up the name
            let cleanType = swiftClassName(objcType)
            return "\(baseName)\(cleanType)"
        }
    }

    private func swiftPropertyName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return name }

        // Process each word
        var processedWords: [String] = []

        for (index, word) in words.enumerated() {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if index == 0 {
                // First word should be lowercase, except for special cases
                if upperWord == "URL" || upperWord == "UUID" || upperWord == "ID" ||
                   upperWord == "HTTP" || upperWord == "HTTPS" || upperWord == "XML" ||
                   upperWord == "HTML" || upperWord == "PDF" || upperWord == "UI" ||
                   upperWord == "API" {
                    processedWords.append(cleanWord.lowercased())
                } else {
                    processedWords.append(cleanWord.lowercased())
                }
            } else if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
                      upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
                      upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
                      upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else {
                // Subsequent words should be capitalized
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        return processedWords.joined()
    }

    private func swiftMethodName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return name }

        // Process each word
        var processedWords: [String] = []

        for (index, word) in words.enumerated() {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
               upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
               upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
               upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else if index == 0 {
                // First word should be lowercase
                processedWords.append(cleanWord.lowercased())
            } else {
                // Subsequent words should be capitalized
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        return processedWords.joined()
    }

    private func swiftClassName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return name }

        // Process each word by capitalizing first letter
        var processedWords: [String] = []

        for word in words {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
               upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
               upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
               upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else {
                // All words should be capitalized for type names
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        return processedWords.joined()
    }

    private func generateStronglyTypedExtensions() -> String {
        var code = """

        // MARK: - Strongly Typed Extensions

        """

        for suite in model.suites {
            for sdefClass in suite.classes {
                if !sdefClass.elements.isEmpty {
                    code += generateStronglyTypedExtension(sdefClass, suite: suite)
                }
            }
        }

        return code
    }

    private func generateStronglyTypedExtension(_ sdefClass: SDEFClass, suite: SDEFSuite) -> String {
        let protocolName = "\(baseName)\(swiftClassName(sdefClass.name))"

        var code = """

        /// Strongly typed accessors for \(sdefClass.name)
        public extension \(protocolName) {
        """

        for element in sdefClass.elements {
            // Look up the class to get its plural name and generate typed accessor
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }

            var methodName: String
            var pluralPropertyName: String

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name
                methodName = swiftMethodName(pluralName)
                pluralPropertyName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s"
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
                pluralPropertyName = swiftMethodName(pluralForm)
            }

            let elementTypeName = "\(baseName)\(swiftClassName(element.type))"
            let prefixedPropertyName = baseName.lowercaseFirstLetter() + pluralPropertyName.capitalizingFirstLetter()

            code += """

                /// Strongly typed accessor for \(element.type) elements
                var \(prefixedPropertyName): [\(elementTypeName)] {
                    \(methodName)?() as? [\(elementTypeName)] ?? []
                }
            """
        }

        code += """

        }
        """

        return code
    }

    private func swiftCaseName(_ name: String) -> String {
        let cleaned = name
            .replacingOccurrences(of: " ", with: "")
            .replacingOccurrences(of: "-", with: "")
            .replacingOccurrences(of: "_", with: "")

        return cleaned.lowercaseFirstLetter()
    }

    private func formatEnumeratorCode(_ code: String) -> String {
        // Convert 4-character codes to proper format
        if code.count == 4 {
            let chars = Array(code)
            let formatted = chars.compactMap { char in
                guard let ascii = char.asciiValue else { return "00" }
                return String(format: "%02x", ascii)
            }.joined()
            return "0x\(formatted)"
        }
        // Handle other code formats
        if code.hasPrefix("0x") || code.allSatisfy({ $0.isHexDigit }) {
            return code.hasPrefix("0x") ? code : "0x\(code)"
        }
        return "'\(code)'"
    }

    /// Generates a public enum containing all scripting class names from the SDEF.
    ///
    /// This method creates a CaseIterable, RawRepresentable enum that encompasses all
    /// scripting class names found in the SDEF file, including both regular classes
    /// and class extensions. The enum cases are generated using a transformation
    /// similar to the Python reference implementation, converting class names to
    /// proper Swift enum case names.
    ///
    /// - Returns: Swift code for the class names enumeration
    private func generateClassNamesEnum() -> String {
        var classNames = Set<String>()

        // Collect all class names (parser already filtered hidden classes if needed)
        for suite in model.suites {
            for sdefClass in suite.classes {
                classNames.insert(sdefClass.name)
            }

            // Also collect class extension names
            for classExtension in suite.classExtensions {
                classNames.insert(classExtension.extends)
            }
        }

        // Sort names for consistent output
        let sortedNames = classNames.sorted()

        var code = """

        /// An enumeration of all scripting class names available in this application.
        ///
        /// This enum provides a type-safe way to reference all scriptable classes defined
        /// in the application's scripting dictionary. Each case corresponds to a class
        /// that can be accessed through the Scripting Bridge framework.
        public enum \(baseName)ScriptingClassNames: String, CaseIterable {

        """

        for name in sortedNames {
            let caseName = transformToEnumCase(name)
            code += "    case \(caseName) = \"\(name)\"\n"
        }

        code += "}\n\n"

        return code
    }

    /// Transforms a class name into a proper Swift enum case name.
    ///
    /// This method implements the same transformation logic as the Python reference,
    /// converting class names by removing quotes and hyphens, capitalizing words,
    /// and then converting to camelCase for the enum case.
    ///
    /// - Parameter name: The original class name from the SDEF
    /// - Returns: A properly formatted Swift enum case name
    private func transformToEnumCase(_ name: String) -> String {
        // Remove quotes and replace hyphens with spaces
        let transformed = name
            .replacingOccurrences(of: "\"", with: "")
            .replacingOccurrences(of: "-", with: " ")

        // Capitalize each word and remove spaces
        let words = transformed.components(separatedBy: " ")
        let capitalized = words.map { $0.capitalizingFirstLetter() }.joined()

        // Convert to camelCase (first letter lowercase)
        return capitalized.lowercaseFirstLetter()
    }
}

/// Errors that can occur during Swift code generation.
///
/// These errors indicate problems encountered while transforming SDEF model data
/// into Swift source code, such as unsupported type definitions or invalid
/// naming conventions that cannot be mapped to valid Swift identifiers.
public enum SDEFCodeGenerationError: Error {
    /// An unsupported SDEF type was encountered that cannot be mapped to Swift
    case unsupportedType(String)

    /// An invalid identifier name was found that cannot be converted to valid Swift
    case invalidIdentifier(String)

    /// A structural problem in the SDEF model prevents code generation
    case invalidModel(String)
}

extension SDEFCodeGenerationError: LocalizedError {
    /// A localised description of the code generation error.
    ///
    /// Provides detailed error messages that explain what went wrong during the
    /// Swift code generation process. These messages are designed to help developers
    /// understand and resolve issues with their SDEF files or generation configuration.
    ///
    /// - Returns: A descriptive error message suitable for display or logging
    public var errorDescription: String? {
        switch self {
        case .unsupportedType(let type):
            return "Unsupported SDEF type: \(type)"
        case .invalidIdentifier(let identifier):
            return "Invalid Swift identifier: \(identifier)"
        case .invalidModel(let message):
            return "Invalid SDEF model: \(message)"
        }
    }
}

// MARK: - String Extensions

extension String {
    /// Returns a copy of the string with the first character capitalised.
    ///
    /// This method converts the first character of the string to uppercase while
    /// leaving the rest of the string unchanged. It's commonly used for converting
    /// identifiers to proper Swift type names and method names.
    ///
    /// - Returns: A string with the first character capitalised
    func capitalizingFirstLetter() -> String {
        return prefix(1).uppercased() + dropFirst()
    }

    /// Returns a copy of the string with the first character in lowercase.
    ///
    /// This method converts the first character of the string to lowercase while
    /// preserving the case of all other characters. It's used for generating
    /// proper Swift property and variable names from SDEF identifiers.
    ///
    /// - Returns: A string with the first character in lowercase
    func lowercaseFirstLetter() -> String {
        return prefix(1).lowercased() + dropFirst()
    }
}
