//
// SDEFSwiftCodeGenerator.swift
// SDEF
//
// Created by Rene Hexel on 1/06/2024.
// Copyright Â© 2024, 2025 Rene Hexel. All rights reserved.
//
import Foundation
import SwiftSyntax
import SwiftSyntaxBuilder

/// A code generator that produces Swift Scripting Bridge code from parsed SDEF models.
///
/// The `SDEFSwiftCodeGenerator` transforms structured SDEF data into clean, type-safe Swift code
/// that provides interfaces for controlling scriptable macOS applications through the Scripting
/// Bridge framework. The generator handles proper Swift naming conventions, type mapping, and
/// protocol generation to create idiomatic Swift code from Apple Event definitions.
///
/// The generated code includes protocols for each scriptable class, enumerations for constant
/// values, type aliases for common Scripting Bridge types, and extension methods that provide
/// a complete Swift interface to the application's scripting capabilities.
public final class SDEFSwiftCodeGenerator {
    private let model: SDEFModel
    private let baseName: String
    private let shouldGenerateClassNamesEnum: Bool
    private let shouldGenerateStronglyTypedExtensions: Bool
    private let generatePrefixedTypealiases: Bool
    private let generateFlatTypealiases: Bool
    private let bundleIdentifier: String?
    private let isIncludedFile: Bool
    private let verbose: Bool
    private lazy var enumerationNames: Set<String> = {
        var names = Set<String>()
        for suite in model.suites {
            for enumeration in suite.enumerations {
                let enumName = swiftClassName(enumeration.name)
                names.insert(enumName)
            }
        }
        return names
    }()

    /// Creates a new Swift code generator with the specified configuration.
    ///
    /// The generator uses the provided SDEF model to create comprehensive Swift code that
    /// mirrors the application's scripting interface. The basename parameter determines
    /// the prefix used for all generated types, ensuring they don't conflict with other
    /// generated code in the same project.
    ///
    /// - Parameters:
    ///   - model: The parsed SDEF model containing all scripting definitions
    ///   - basename: The prefix to use for all generated Swift types
    ///   - shouldGenerateClassNamesEnum: Whether to generate an enum containing all scripting class names
    ///   - shouldGenerateStronglyTypedExtensions: Whether to generate strongly typed accessor extensions
    ///   - generatePrefixedTypealiases: Whether to generate prefixed typealiases for backward compatibility
    ///   - generateFlatTypealiases: Whether to generate flat (unprefixed) typealiases
    ///   - bundleIdentifier: Optional bundle identifier for generating application() convenience function
    ///   - isIncludedFile: Whether this is an included file (skips foundation protocols)
    ///   - verbose: Whether to enable detailed logging during code generation
    public init(model: SDEFModel, basename: String, shouldGenerateClassNamesEnum: Bool, shouldGenerateStronglyTypedExtensions: Bool, generatePrefixedTypealiases: Bool = false, generateFlatTypealiases: Bool = false, bundleIdentifier: String? = nil, isIncludedFile: Bool = false, verbose: Bool) {
        self.model = model
        self.baseName = basename
        self.shouldGenerateClassNamesEnum = shouldGenerateClassNamesEnum
        self.shouldGenerateStronglyTypedExtensions = shouldGenerateStronglyTypedExtensions
        self.generatePrefixedTypealiases = generatePrefixedTypealiases
        self.generateFlatTypealiases = generateFlatTypealiases
        self.bundleIdentifier = bundleIdentifier
        self.isIncludedFile = isIncludedFile
        self.verbose = verbose
    }

    /// Generates complete Swift source code from the SDEF model.
    ///
    /// This method produces a complete Swift source file that includes all necessary imports,
    /// type definitions, protocols, and extensions needed to interact with the scriptable
    /// application. The generated code follows Swift best practices and provides type-safe
    /// interfaces that mirror the application's Apple Event scripting capabilities.
    ///
    /// The generation process creates several components: standard protocol definitions for
    /// generic scripting methods, enumerations for constant values, protocols for each
    /// scriptable class with their properties and methods, and extensions that conform
    /// Scripting Bridge types to these protocols.
    ///
    /// - Returns: A complete Swift source code string ready to be written to a file
    /// - Throws: `SDEFCodeGenerationError` if the model contains invalid or unsupported definitions
    public func generateCode() throws -> String {
        var code = """
        //
        // \(baseName).swift
        // Generated by sdef2swift
        //
        import Foundation
        import ScriptingBridge
        import AppKit

        """

        // Generate foundation protocols - always prefixed to avoid conflicts between different SDEF files
        code += """

        /// Protocol for ScriptingBridge Objects.
        ///
        /// This protocol defines the basic functionality for ScriptingBridge objects.
        @objc public protocol \(baseName)SBObjectProtocol: NSObjectProtocol {
            func get() -> Any!
        }
        extension SBObject: \(baseName)SBObjectProtocol {}

        /// Protocol for ScriptingBridge Applications.
        ///
        /// This protocol defines the basic functionality for ScriptingBridge applications,
        /// including standard Apple Event commands that most applications support.
        @objc public protocol \(baseName)SBApplicationProtocol: \(baseName)SBObjectProtocol {
            // MARK: - Core Application Methods

            /// Activate the application, bringing it to the foreground.
            func activate()

            /// The application's delegate for handling Scripting Bridge events.
            var delegate: SBApplicationDelegate! { get set }

            /// Whether the application is currently running.
            var isRunning: Bool { get }

            // MARK: - Standard Suite Commands

            /// Open the specified object(s).
            /// - Parameters:
            ///   - objects: List of objects to open
            ///   - using: The application file to open the object with (optional)
            ///   - withProperties: Initial values for properties (optional)
            @objc optional func open(_ objects: Any!, using: Any?, withProperties: [String: Any]?)

            /// Print the specified object(s).
            /// - Parameters:
            ///   - objects: List of objects to print
            ///   - withProperties: Optional properties for the print command
            @objc optional func print(_ objects: Any!, withProperties: [String: Any]?)

            /// Quit the application.
            @objc optional func quit()

            /// Close the specified object.
            /// - Parameter object: The object to close
            @objc optional func close(_ object: Any!)

            /// Return the number of elements of a particular class within an object.
            /// - Parameters:
            ///   - object: The object whose elements are to be counted
            ///   - each: The class of elements to count
            /// - Returns: The number of elements
            @objc optional func count(_ object: Any!, each: Any!) -> Int

            /// Return the size in bytes of an object.
            /// - Parameters:
            ///   - object: The object whose data size is to be returned
            ///   - as: The data type for which the size is calculated (optional)
            /// - Returns: The size of the object in bytes
            @objc optional func dataSize(_ object: Any!, as: Any?) -> Int

            /// Move an item from its container to the trash.
            /// - Parameter object: The item to delete
            /// - Returns: The item that was just deleted
            @objc optional func delete(_ object: Any!) -> Any!

            /// Duplicate one or more object(s).
            /// - Parameters:
            ///   - objects: The object(s) to duplicate
            ///   - to: The new location for the object(s) (optional)
            ///   - replacing: Whether to replace items with the same name (optional)
            ///   - routingSuppressed: Whether to suppress autorouting (optional)
            ///   - exactCopy: Whether to copy permissions/ownership as is (optional)
            /// - Returns: The duplicated object(s)
            @objc optional func duplicate(_ objects: Any!, to: Any?, replacing: Bool, routingSuppressed: Bool, exactCopy: Bool) -> Any!

            /// Verify if an object exists.
            /// - Parameter object: The object in question
            /// - Returns: True if it exists, false if not
            @objc optional func exists(_ object: Any!) -> Bool

            /// Make a new element.
            /// - Parameters:
            ///   - new: The class of the new element
            ///   - at: The location at which to insert the element
            ///   - to: When creating an alias, the original item (optional)
            ///   - withProperties: Initial values for properties (optional)
            /// - Returns: The new object(s)
            @objc optional func make(new: Any!, at: Any!, to: Any?, withProperties: [String: Any]?) -> Any!

            /// Move object(s) to a new location.
            /// - Parameters:
            ///   - objects: The object(s) to move
            ///   - to: The new location for the object(s)
            ///   - replacing: Whether to replace items with the same name (optional)
            ///   - positionedAt: List of positions for destination items (optional)
            ///   - routingSuppressed: Whether to suppress autorouting (optional)
            /// - Returns: The object(s) after they have been moved
            @objc optional func move(_ objects: Any!, to: Any!, replacing: Bool, positionedAt: [Any]?, routingSuppressed: Bool) -> Any!

            /// Select the specified object(s).
            /// - Parameter object: The object to select
            @objc optional func select(_ object: Any!)
        }
        extension SBApplication: \(baseName)SBApplicationProtocol {}

        """

        // Generate standard protocols and enums first (outside namespace)
        code += generateApplicationProtocol()

        // Start namespace enum
        code += "\n\n// MARK: - \(baseName) Namespace\n\n"
        code += "/// Namespace for all \(baseName) scripting types.\n"
        code += "public enum \(baseName) {\n"

        // Generate type aliases inside namespace
        code += generateNamespacedTypeAliases()

        // Generate standard enums inside namespace
        code += generateNamespacedStandardEnums()

        // Generate class names enum if requested
        if shouldGenerateClassNamesEnum {
            code += generateNamespacedClassNamesEnum()
        }

        // Generate enumerations inside namespace - deduplicate by name
        var generatedEnumNames = Set<String>()
        for suite in model.suites {
            for enumeration in suite.enumerations {
                let enumName = swiftClassName(enumeration.name)
                if !generatedEnumNames.contains(enumName) {
                    code += generateNamespacedEnumeration(enumeration)
                    generatedEnumNames.insert(enumName)
                } else if verbose {
                    print("Skipping duplicate enumeration: \(enumName)")
                }
            }
        }

        // Generate protocols for standard classes that haven't been merged (inside namespace)
        let mergedClassNames = Set(model.suites.flatMap { $0.classes }.map { $0.name })
        for standardClass in model.standardClasses {
            // Only generate if this standard class hasn't been merged into a regular class
            if !mergedClassNames.contains(standardClass.name) {
                code += generateNamespacedClassProtocol(standardClass, suite: SDEFSuite(name: "Standard", code: "std", description: "Standard classes", classes: [], enumerations: [], commands: [], classExtensions: []))
            }
        }

        // Generate protocols for classes (inside namespace)
        for suite in model.suites {
            for sdefClass in suite.classes {
                code += generateNamespacedClassProtocol(sdefClass, suite: suite)
            }

            // Generate protocols for class extensions (inside namespace)
            for classExtension in suite.classExtensions {
                code += generateNamespacedClassExtensionProtocol(classExtension, suite: suite)
            }
        }

        // Generate application() convenience function if bundle identifier is provided
        if let bundleIdentifier = bundleIdentifier {
            code += generateApplicationFunction(bundleIdentifier: bundleIdentifier)
        }

        // Close namespace enum
        code += "\n}\n"

        // Generate SBObject extensions for namespaced protocols
        code += generateNamespacedSBObjectExtensions()

        // Generate strongly typed extensions if requested
        if shouldGenerateStronglyTypedExtensions {
            code += generateStronglyTypedExtensions()
        }

        // Generate SBApplication extension
        code += generateSBApplicationExtension()

        // Generate prefixed typealiases if requested
        if generatePrefixedTypealiases {
            code += generatePrefixedTypealiasesSection()
        }

        // Generate flat typealiases if requested
        if generateFlatTypealiases {
            code += generateFlatTypealiasesSection()
        }

        return code
    }

    private func generateTypeAliases() -> String {
        // Check if the SDEF model defines an Application class
        let hasApplicationClass = model.suites.contains { suite in
            suite.classes.contains { sdefClass in
                sdefClass.name.lowercased() == "application"
            }
        }

        var aliases = """

// MARK: - Type Aliases

"""

        if !hasApplicationClass {
            aliases += "public typealias \(baseName)Application = SBApplication\n"
        }

        aliases += """
public typealias \(baseName)Object = SBObject
public typealias \(baseName)ElementArray = SBElementArray

"""
        return aliases
    }

    private func generateEnumeration(_ enumeration: SDEFEnumeration) -> String {
        let enumName = "\(baseName)\(enumeration.name.capitalizingFirstLetter().replacingOccurrences(of: " ", with: "").replacingOccurrences(of: "-", with: ""))"

        var code = """

        // MARK: - \(enumeration.name)

        """

        if let description = enumeration.description {
            code += "/// \(description.capitalizingFirstLetter())\n"
        }

        code += "@objc public enum \(enumName): AEKeyword, Sendable {\n"

        // Track used raw values and their corresponding case names
        var usedRawValues: [String: String] = [:]
        var aliasProperties: [String] = []

        for enumerator in enumeration.enumerators {
            if let description = enumerator.description {
                code += "    /// \(description.capitalizingFirstLetter())\n"
            }

            let caseName = swiftCaseName(enumerator.name)
            let codeValue = formatEnumeratorCode(enumerator.code)

            // Check if we've already used this raw value
            if let existingCaseName = usedRawValues[codeValue] {
                // Create an alias property instead of a duplicate case
                if verbose {
                    print("Creating alias \(caseName) -> \(existingCaseName) for duplicate raw value \(codeValue) in \(enumName)")
                }
                aliasProperties.append("    /// Alias for \(existingCaseName)")
                aliasProperties.append("    public static let \(caseName): \(enumName) = .\(existingCaseName)")
            } else {
                // This is a new raw value, create the actual case
                usedRawValues[codeValue] = caseName
                code += "    case \(caseName) = \(codeValue)\n"
            }
        }

        // Add alias properties after the cases
        if !aliasProperties.isEmpty {
            code += "\n    // MARK: - Aliases for duplicate raw values\n"
            for aliasProperty in aliasProperties {
                code += "\(aliasProperty)\n"
            }
        }

        code += "}\n"

        return code
    }

    private func generateClassProtocol(_ sdefClass: SDEFClass, suite: SDEFSuite) -> String {
        let protocolName = "\(baseName)\(swiftClassName(sdefClass.name))"

        var code = """

        // MARK: - \(sdefClass.name)

        """

        if let description = sdefClass.description {
            code += "/// \(description.capitalizingFirstLetter())\n"
        }

        var inheritanceList: [String]

        // Application classes should inherit from SBApplicationProtocol, others from SBObjectProtocol
        // Always use prefixed versions to avoid conflicts between different SDEF files
        if sdefClass.name.lowercased() == "application" {
            inheritanceList = ["\(baseName)SBApplicationProtocol"]
        } else {
            inheritanceList = ["\(baseName)SBObjectProtocol"]
        }

        // Add GenericMethods for standard classes
        if ["window", "document", "application"].contains(sdefClass.name.lowercased()) {
            inheritanceList.append("\(baseName)GenericMethods")
        }

        if let inherits = sdefClass.inherits {
            let cleanInherits = swiftClassName(inherits)

            // Check if the inherited class actually exists in the model
            let allClasses = model.suites.flatMap { $0.classes } + model.standardClasses
            let inheritsClassExists = allClasses.contains { $0.name.lowercased() == inherits.lowercased() }

            if inheritsClassExists {
                inheritanceList.append("\(baseName)\(cleanInherits)")
            } else if verbose {
                print("Warning: Class '\(sdefClass.name)' inherits from '\(inherits)' but '\(inherits)' is not defined in the SDEF model")
            }
        }

        code += "@objc public protocol \(protocolName): \(inheritanceList.joined(separator: ", ")) {\n"

        // Generate properties
        for property in sdefClass.properties {
            code += generateProperty(property)
        }

        // Generate element arrays
        for element in sdefClass.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
                ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "    /// Array of \(element.type) objects - \(description.lowercaseFirstLetter())\n"
            }

            code += "    @objc(\(methodName)) optional func untyped\(methodName.capitalizingFirstLetter())() -> SBElementArray\n"
        }

        // Generate setter methods only for write-only properties
        for property in sdefClass.properties {
            if property.access == "w" { // Write-only properties need explicit setter methods
                let propertyName = if let cocoaKey = property.cocoaKey {
                    // Cocoa keys are already in proper Swift naming convention
                    escapeReservedKeyword(cocoaKey)
                } else {
                    swiftPropertyName(property.name)
                }
                let swiftType = swiftSetterParameterType(for: property.type)

                // Generate DocC comment for setter
                if let description = property.description {
                    let setterDescription = "Set \(description.lowercaseFirstLetter())"
                    code += "    /// \(setterDescription.capitalizingFirstLetter())\n"
                }

                // Fix setter naming for special cases
                let setterName = switch property.name.lowercased() {
                case "current tab":
                    "CurrentTab"
                case "url":
                    "URL"
                default:
                    swiftClassName(property.name)
                }

                code += "    @objc optional func set\(setterName)(_ \(propertyName): \(swiftType))\n"
            }
        }

        code += "}\n"

        // Generate extension - SBApplication for application classes, SBObject for others
        if sdefClass.name.lowercased() == "application" {
            code += """

            extension SBApplication: \(protocolName) {}

            """
        } else {
            code += """

            extension SBObject: \(protocolName) {}

            """
        }

        return code
    }

    private func generateClassExtensionProtocol(_ classExtension: SDEFClassExtension, suite: SDEFSuite) -> String {
        let baseTypeName = swiftClassName(classExtension.extends)
        let protocolName = "\(baseName)\(baseTypeName)"

        var code = """

        // MARK: - \(classExtension.extends) Extension

        @objc public protocol \(protocolName): SBObject {

        """

        // Generate properties
        for property in classExtension.properties {
            code += generateProperty(property)
        }

        // Generate element arrays
        for element in classExtension.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
                ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "    /// Array of \(element.type) objects - \(description.lowercaseFirstLetter())\n"
            }

            code += "    @objc(\(methodName)) optional func untyped\(methodName.capitalizingFirstLetter())() -> SBElementArray\n"
        }

        code += "}\n"

        // Generate SBObject extension
        code += """

        extension SBObject: \(protocolName) {}

        """

        return code
    }

    private func generateNamespacedClassProtocol(_ sdefClass: SDEFClass, suite: SDEFSuite) -> String {
        let protocolName = swiftClassName(sdefClass.name)

        var code = """

            // MARK: - \(sdefClass.name)

        """

        if let description = sdefClass.description {
            code += "    /// \(description.capitalizingFirstLetter())\n"
        }

        var inheritanceList: [String]

        // Application classes should inherit from SBApplicationProtocol, others from SBObjectProtocol
        // Use prefixed versions from outside the namespace
        if sdefClass.name.lowercased() == "application" {
            inheritanceList = ["\(baseName)SBApplicationProtocol"]
        } else {
            inheritanceList = ["\(baseName)SBObjectProtocol"]
        }

        // Add GenericMethods for standard classes
        if ["window", "document", "application"].contains(sdefClass.name.lowercased()) {
            inheritanceList.append("\(baseName)GenericMethods")
        }

        if let inherits = sdefClass.inherits {
            let cleanInherits = swiftClassName(inherits)

            // Check if the inherited class actually exists in the model
            let allClasses = model.suites.flatMap { $0.classes } + model.standardClasses
            let inheritsClassExists = allClasses.contains { $0.name.lowercased() == inherits.lowercased() }

            if inheritsClassExists {
                // Reference within the same namespace
                inheritanceList.append(cleanInherits)
            } else if verbose {
                print("Warning: Class '\(sdefClass.name)' inherits from '\(inherits)' but '\(inherits)' is not defined in the SDEF model")
            }
        }

        code += "    @objc(\(baseName)\(protocolName)) public protocol \(protocolName): \(inheritanceList.joined(separator: ", ")) {\n"

        // Generate properties
        for property in sdefClass.properties {
            code += generateNamespacedProperty(property)
        }

        // Generate element arrays
        for element in sdefClass.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
                ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "        /// Array of \(element.type) objects - \(description.lowercaseFirstLetter())\n"
            }

            code += "        @objc(\(methodName)) optional func untyped\(methodName.capitalizingFirstLetter())() -> SBElementArray\n"
        }

        // Generate setter methods only for write-only properties
        for property in sdefClass.properties {
            if property.access == "w" { // Write-only properties need explicit setter methods
                let propertyName = if let cocoaKey = property.cocoaKey {
                    // Cocoa keys are already in proper Swift naming convention
                    escapeReservedKeyword(cocoaKey)
                } else {
                    swiftPropertyName(property.name)
                }
                let swiftType = swiftSetterParameterType(for: property.type)

                // Generate DocC comment for setter
                if let description = property.description {
                    let setterDescription = "Set \(description.lowercaseFirstLetter())"
                    code += "        /// \(setterDescription.capitalizingFirstLetter())\n"
                }

                // Fix setter naming for special cases
                let setterName = switch property.name.lowercased() {
                case "current tab":
                    "CurrentTab"
                case "url":
                    "URL"
                default:
                    propertyName.capitalizingFirstLetter()
                }

                code += "        @objc optional func set\(setterName)(_ \(propertyName): \(swiftType))\n"
            }
        }

        code += "    }\n"

        return code
    }

    private func generateNamespacedClassExtensionProtocol(_ classExtension: SDEFClassExtension, suite: SDEFSuite) -> String {
        let baseTypeName = swiftClassName(classExtension.extends)
        let protocolName = baseTypeName

        var code = """

            // MARK: - \(classExtension.extends) Extension

            @objc(\(baseName)\(protocolName)) public protocol \(protocolName): SBObject {

        """

        // Generate properties
        for property in classExtension.properties {
            code += generateNamespacedProperty(property)
        }

        // Generate element arrays
        for element in classExtension.elements {
            // Look up the class to get its plural name
            var methodName: String

            // Find the class definition for this element type
            // First check in regular classes, then in standard classes
            let elementClass = model.suites.flatMap { $0.classes }.first { $0.name == element.type }
                ?? model.standardClasses.first { $0.name == element.type }

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name and convert to camelCase
                methodName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s" and convert to camelCase
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
            }

            // Add documentation if available
            if let elementClass = elementClass, let description = elementClass.description {
                code += "        /// Array of \(element.type) objects - \(description.lowercaseFirstLetter())\n"
            }

            code += "        @objc(\(methodName)) optional func untyped\(methodName.capitalizingFirstLetter())() -> SBElementArray\n"
        }

        code += "    }\n"

        return code
    }

    private func generateNamespacedProperty(_ property: SDEFProperty) -> String {
        var code = ""

        if let description = property.description {
            code += "        /// \(description.capitalizingFirstLetter())\n"
        }

        // Protocol should use the original SDEF property name (Objective-C style)
        // This provides the canonical property names that match AppleScript/Objective-C conventions
        let basePropertyName = swiftPropertyName(property.name)

        // For list properties, use "untyped" prefix and SBElementArray
        let (propertyName, swiftType) = if property.type.isList {
            ("untyped" + basePropertyName.capitalizingFirstLetter(), "SBElementArray")
        } else {
            (basePropertyName, swiftNamespacedType(for: property.type))
        }

        let accessors = switch property.access {
        case "r":
            "{ get }"
        case "rw", "":
            "{ get set }"
        case "w":
            "{ get set }" // Even write-only properties need to be readable in Swift protocols
        default:
            "{ get set }"
        }

        // Protocol uses the standard property name without @objc renaming
        // The property name itself matches the Objective-C/AppleScript convention
        code += "        @objc optional var \(propertyName): \(swiftType) \(accessors)\n"

        return code
    }

    private func generateNamespacedSBObjectExtensions() -> String {
        var code = ""

        // Generate extensions for standard classes that haven't been merged
        let mergedClassNames = Set(model.suites.flatMap { $0.classes }.map { $0.name })
        for standardClass in model.standardClasses {
            // Only generate if this standard class hasn't been merged into a regular class
            if !mergedClassNames.contains(standardClass.name) {
                let protocolName = swiftClassName(standardClass.name)
                if standardClass.name.lowercased() == "application" {
                    code += "\nextension SBApplication: \(baseName).\(protocolName) {}\n"
                } else {
                    code += "\nextension SBObject: \(baseName).\(protocolName) {}\n"
                }
            }
        }

        // Generate extensions for regular classes
        for suite in model.suites {
            for sdefClass in suite.classes {
                let protocolName = swiftClassName(sdefClass.name)
                if sdefClass.name.lowercased() == "application" {
                    code += "\nextension SBApplication: \(baseName).\(protocolName) {}\n"
                } else {
                    code += "\nextension SBObject: \(baseName).\(protocolName) {}\n"
                }
            }

            // Generate extensions for class extensions
            for classExtension in suite.classExtensions {
                let protocolName = swiftClassName(classExtension.extends)
                code += "\nextension SBObject: \(baseName).\(protocolName) {}\n"
            }
        }

        return code
    }

    private func generateProperty(_ property: SDEFProperty) -> String {
        var code = ""

        if let description = property.description {
            code += "    /// \(description.capitalizingFirstLetter())\n"
        }

        // Use cocoa key if available, otherwise use the property name
        let basePropertyName = if let cocoaKey = property.cocoaKey {
            // Cocoa keys are already in proper Swift naming convention (e.g., isShared)
            // Just escape reserved keywords if needed
            escapeReservedKeyword(cocoaKey)
        } else {
            swiftPropertyName(property.name)
        }

        // For list properties, use "untyped" prefix and SBElementArray
        let (propertyName, swiftType) = if property.type.isList {
            ("untyped" + basePropertyName.capitalizingFirstLetter(), "SBElementArray")
        } else {
            (basePropertyName, swiftType(for: property.type))
        }

        let accessors = switch property.access {
        case "r":
            " { get }"
        case "w":
            " { set }"
        default:
            " { get set }"
        }

        // Always use the original SDEF property name for @objc attribute for ABI compatibility
        // Convert to valid Swift identifier (camelCase) if needed
        let objcName = swiftPropertyName(property.name)
        code += "    @objc(\(objcName)) optional var \(propertyName): \(swiftType)\(accessors)\n"

        return code
    }

    private func generateApplicationProtocol() -> String {
        // Always use prefixed base protocol to avoid conflicts between different SDEF files
        let applicationBaseProtocol = "\(baseName)SBApplicationProtocol"

        return """

        // MARK: - Generic Methods Protocol

        @objc public protocol \(baseName)GenericMethods {
            @objc optional func closeSaving(_ saving: \(baseName).SaveOptions, savingIn: URL?)
            @objc optional func saveIn(_ in_: URL?, as: Any?)
            @objc optional func printWithProperties(_ withProperties: [String: Any]?, printDialog: Bool)
            @objc optional func delete()
            @objc optional func duplicateTo(_ to: SBObject?, withProperties: [String: Any]?)
            @objc optional func moveTo(_ to: SBObject?)
        }

        // MARK: - Application Protocol

        @objc public protocol \(baseName)ApplicationProtocol: \(applicationBaseProtocol) {
            /// Array of document objects - A document.
            @objc optional func documents() -> SBElementArray
            /// Array of window objects - A window.
            @objc optional func windows() -> SBElementArray
        }

        """
    }

    private func generateApplicationFunction(bundleIdentifier: String) -> String {
        // Check if the SDEF model defines an Application class
        let hasApplicationClass = model.suites.contains { suite in
            suite.classes.contains { sdefClass in
                sdefClass.name.lowercased() == "application"
            }
        }

        guard hasApplicationClass else {
            // If there's no Application class defined, don't generate the function
            return ""
        }

        return """

            // MARK: - Application Convenience Function

            /// Return an instance of the application.
            ///
            /// This property creates an instance of the application using its bundle identifier
            /// and returns an optional Application instance if the application is available
            public static : \(baseName).Application! {
                SBApplication(bundleIdentifier: "\(bundleIdentifier)")
            }
        """
    }

    private func generateSBApplicationExtension() -> String {
        return """

        extension SBApplication: \(baseName)ApplicationProtocol {}

        extension SBObject: \(baseName)GenericMethods {}

        """
    }

    // MARK: - Helper Methods

    private func swiftType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftTypeName(propertyType.baseType)

        if propertyType.isList {
            // Check if the base type is an enum (not representable in Objective-C arrays)
            let allEnumNames = model.suites.flatMap { $0.enumerations }.map { swiftClassName($0.name) }
            let isEnumType = allEnumNames.contains(baseType)

            if verbose {
                print("Checking list property: baseType='\(baseType)', allEnums=\(allEnumNames), isEnum=\(isEnumType)")
            }

            if isEnumType {
                // For enum arrays, use SBElementArray for @objc compatibility
                if verbose {
                    print("Converting enum array [\(baseType)] to SBElementArray for Objective-C compatibility")
                }
                baseType = "SBElementArray"
            } else {
                // For protocol/class arrays, use Swift array syntax (Objective-C compatible)
                baseType = "[\(baseType)]"
            }
        }

        // For @objc optional properties, never make types optional to avoid double optionals
        // The @objc optional already provides the optionality
        return baseType
    }

    private func swiftSetterParameterType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftTypeName(propertyType.baseType)

        if propertyType.isList {
            baseType = "[\(baseType)]"
        }

        // For setter method parameters, preserve optionality as it's separate from @objc optional
        if propertyType.isOptional {
            baseType += "?"
        }

        return baseType
    }

    private func swiftTypeName(_ objcType: String) -> String {
        switch objcType.lowercased() {
        case "text", "string":
            return "String"
        case "integer", "int":
            return "Int"
        case "real", "double":
            return "Double"
        case "boolean", "bool":
            return "Bool"
        case "date":
            return "Date"
        case "file", "alias":
            return "URL"
        case "record":
            return "[String: Any]"
        case "any":
            return "Any"
        case "missing value":
            return "NSNull"
        case "rectangle":
            return "NSRect"
        case "number":
            return "NSNumber"
        case "point":
            return "NSPoint"
        case "size":
            return "NSSize"
        case "specifier":
            return "SBObject"
        case "location specifier":
            return "SBObject"
        case "type":
            return "OSType"
        case "picture":
            return "NSImage"
        case "enum":
            return "OSType"
        case "double integer":
            return "Int64"
        default:
            // Check if it's an enumeration type
            let cleanType = swiftClassName(objcType)
            if enumerationNames.contains(cleanType) {
                // It's an enum - use namespace
                return "\(baseName).\(cleanType)"
            } else {
                // It's a class name - use protocol name
                return "\(baseName)\(cleanType)"
            }
        }
    }

    private func swiftNamespacedType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftNamespacedTypeName(propertyType.baseType)

        if propertyType.isList {
            baseType = "[\(baseType)]"
        }

        // For @objc optional properties, never make types optional to avoid double optionals
        // The @objc optional already provides the optionality
        return baseType
    }

    private func swiftNamespacedTypeName(_ objcType: String) -> String {
        switch objcType.lowercased() {
        case "text", "string":
            return "String"
        case "integer", "int":
            return "Int"
        case "real", "double":
            return "Double"
        case "boolean", "bool":
            return "Bool"
        case "date":
            return "Date"
        case "file", "alias":
            return "URL"
        case "record":
            return "[String: Any]"
        case "any":
            return "Any"
        case "missing value":
            return "NSNull"
        case "rectangle":
            return "NSRect"
        case "number":
            return "NSNumber"
        case "point":
            return "NSPoint"
        case "size":
            return "NSSize"
        case "specifier":
            return "SBObject"
        case "location specifier":
            return "SBObject"
        case "type":
            return "OSType"
        case "picture":
            return "NSImage"
        case "enum":
            return "OSType"
        case "double integer":
            return "Int64"
        default:
            // Check if it's an enumeration type
            let cleanType = swiftClassName(objcType)
            if enumerationNames.contains(cleanType) {
                // It's an enum - reference within the same namespace
                return cleanType
            } else {
                // It's a class name - reference within the same namespace
                return cleanType
            }
        }
    }

    private func swiftPropertyName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return escapeReservedKeyword(name) }

        // Process each word
        var processedWords: [String] = []

        for (index, word) in words.enumerated() {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if index == 0 {
                // First word should be lowercase, except for special cases
                if upperWord == "URL" || upperWord == "UUID" || upperWord == "ID" ||
                   upperWord == "HTTP" || upperWord == "HTTPS" || upperWord == "XML" ||
                   upperWord == "HTML" || upperWord == "PDF" || upperWord == "UI" ||
                   upperWord == "API" {
                    processedWords.append(cleanWord.lowercased())
                } else {
                    processedWords.append(cleanWord.lowercased())
                }
            } else if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
                      upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
                      upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
                      upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else {
                // Subsequent words should be capitalized
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        let result = processedWords.joined()
        return escapeReservedKeyword(result)
    }

    private func escapeReservedKeyword(_ name: String) -> String {
        let swiftKeywords = [
            "associatedtype", "class", "deinit", "enum", "extension", "fileprivate", "func",
            "import", "init", "inout", "internal", "let", "open", "operator", "private",
            "protocol", "public", "rethrows", "static", "struct", "subscript", "typealias",
            "var", "break", "case", "continue", "default", "defer", "do", "else", "fallthrough",
            "for", "guard", "if", "in", "repeat", "return", "switch", "where", "while",
            "as", "Any", "catch", "false", "is", "nil", "super", "self", "Self", "throw",
            "throws", "true", "try", "associativity", "convenience", "dynamic", "didSet",
            "final", "get", "infix", "indirect", "lazy", "left", "mutating", "none",
            "nonmutating", "optional", "override", "postfix", "precedence", "prefix",
            "Protocol", "required", "right", "set", "Type", "unowned", "weak", "willSet"
        ]

        if swiftKeywords.contains(name) {
            return "`\(name)`"
        }
        return name
    }

    private func swiftMethodName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return name }

        // Process each word
        var processedWords: [String] = []

        for (index, word) in words.enumerated() {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
               upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
               upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
               upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else if index == 0 {
                // First word should be lowercase
                processedWords.append(cleanWord.lowercased())
            } else {
                // Subsequent words should be capitalized
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        return processedWords.joined()
    }

    private func swiftClassName(_ name: String) -> String {
        // Split by spaces, hyphens, and underscores
        let words = name.components(separatedBy: CharacterSet(charactersIn: " -_"))
            .filter { !$0.isEmpty }

        guard !words.isEmpty else { return name }

        // Process each word by capitalizing first letter
        var processedWords: [String] = []

        for word in words {
            let cleanWord = word.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !cleanWord.isEmpty else { continue }

            // Handle special cases that should remain uppercase
            let upperWord = cleanWord.uppercased()
            if upperWord == "CD" || upperWord == "DVD" || upperWord == "URL" ||
               upperWord == "ID" || upperWord == "UUID" || upperWord == "HTTP" ||
               upperWord == "HTTPS" || upperWord == "XML" || upperWord == "HTML" ||
               upperWord == "PDF" || upperWord == "UI" || upperWord == "API" {
                processedWords.append(upperWord)
            } else {
                // All words should be capitalized for type names
                processedWords.append(cleanWord.capitalizingFirstLetter())
            }
        }

        return processedWords.joined()
    }

    private func generateStronglyTypedExtensions() -> String {
        var code = """

        // MARK: - Strongly Typed Extensions

        """

        // For included files, only process classes from the main suites (not standard classes)
        // For main files, process all classes from main suites
        for suite in model.suites {
            for sdefClass in suite.classes {
                if !sdefClass.elements.isEmpty {
                    if verbose {
                        print("Processing class '\(sdefClass.name)' with \(sdefClass.elements.count) elements:")
                    }
                    code += generateStronglyTypedExtension(sdefClass, suite: suite)
                }
            }
        }

        // For main files only, process standard classes that have elements
        // but skip those that already have corresponding classes in the main suites
        if !isIncludedFile {
            let mainSuiteClassNames = Set(model.suites.flatMap { $0.classes }.map { $0.name.lowercased() })

            for standardClass in model.standardClasses {
                if !standardClass.elements.isEmpty {
                    // Skip standard classes that have corresponding classes in main suites
                    if mainSuiteClassNames.contains(standardClass.name.lowercased()) {
                        if verbose {
                            print("Skipping standard class '\(standardClass.name)' - already defined in main suites")
                        }
                        continue
                    }

                    if verbose {
                        print("Processing standard class '\(standardClass.name)' with \(standardClass.elements.count) elements:")
                    }
                    code += generateStronglyTypedExtension(standardClass, suite: nil)
                }
            }
        }

        return code
    }

    private func generateStronglyTypedExtension(_ sdefClass: SDEFClass, suite: SDEFSuite?) -> String {
        let protocolName = "\(baseName).\(swiftClassName(sdefClass.name))"

        var code = """

        /// Strongly typed accessors for \(sdefClass.name)
        public extension \(protocolName) {
        """

        // Generate strongly typed accessors for element arrays
        for element in sdefClass.elements {
            // Look up the class to get its plural name and generate typed accessor
            // Check both regular classes and standard classes
            let allClasses = model.suites.flatMap { $0.classes } + model.standardClasses
            let elementClass = allClasses.first { $0.name == element.type }

            // Only generate strongly typed accessor if the element type has a corresponding class definition
            guard elementClass != nil else {
                if verbose {
                    print("Skipping strongly typed accessor for \(element.type) - no corresponding class definition found")
                }
                continue
            }

            var methodName: String
            var pluralPropertyName: String

            if let elementClass = elementClass, let pluralName = elementClass.pluralName {
                // Use the defined plural name
                methodName = swiftMethodName(pluralName)
                pluralPropertyName = swiftMethodName(pluralName)
            } else {
                // Fallback: use the type name + "s"
                let pluralForm = element.type + "s"
                methodName = swiftMethodName(pluralForm)
                pluralPropertyName = swiftMethodName(pluralForm)
            }

            let elementTypeName = "\(baseName).\(swiftClassName(element.type))"
            let untypedMethodName = "untyped" + methodName.capitalizingFirstLetter()

            code += """

                /// Strongly typed accessor for \(element.type) elements
                var \(pluralPropertyName): [\(elementTypeName)] {
                    \(untypedMethodName)?() as? [\(elementTypeName)] ?? []
                }
            """
        }

        // Generate strongly typed accessors for list properties
        for property in sdefClass.properties {
            guard property.type.isList else { continue }

            let basePropertyName = if let cocoaKey = property.cocoaKey {
                escapeReservedKeyword(cocoaKey)
            } else {
                swiftPropertyName(property.name)
            }

            // The untyped property name must match the protocol property name (which uses original SDEF name)
            let protocolPropertyName = swiftPropertyName(property.name)
            let untypedPropertyName = "untyped" + protocolPropertyName.capitalizingFirstLetter()
            let baseTypeName = swiftNamespacedTypeName(property.type.baseType)

            // Check if this is an enum type
            let allEnumNames = model.suites.flatMap { $0.enumerations }.map { swiftClassName($0.name) }
            let isEnumType = allEnumNames.contains(baseTypeName)

            if isEnumType {
                // For enum arrays, convert from SBElementArray using raw values
                let enumTypeName = "\(baseName).\(baseTypeName)"
                code += """

                    /// Strongly typed accessor for \(property.name)
                    var \(basePropertyName): [\(enumTypeName)] {
                        guard let untypedArray = \(untypedPropertyName) as? [AEKeyword] else { return [] }
                        return untypedArray.compactMap { \(enumTypeName)(rawValue: $0) }
                    }
                """
            } else {
                // For protocol/class arrays, simple cast should work
                // Only prefix with namespace for class types, not basic types
                let basicTypes = ["String", "Int", "Double", "Bool", "Date", "URL", "[String: Any]", "Any", "NSNull", "NSRect", "NSNumber", "NSPoint", "NSSize", "SBObject"]
                let typeName = if basicTypes.contains(baseTypeName) {
                    baseTypeName
                } else {
                    "\(baseName).\(baseTypeName)"
                }

                code += """

                    /// Strongly typed accessor for \(property.name)
                    var \(basePropertyName): [\(typeName)] {
                        \(untypedPropertyName) as? [\(typeName)] ?? []
                    }
                """
            }
        }

        // Also generate property aliases based on Objective-C names
        code += generatePropertyAliases(sdefClass)

        code += """

        }

        """

        return code
    }

    private func generatePropertyAliases(_ sdefClass: SDEFClass) -> String {
        var code = ""

        // Generate aliases for properties where Cocoa key differs from original property name
        for property in sdefClass.properties {
            guard let cocoaKey = property.cocoaKey else { continue }

            // Generate alias from Swift idiomatic name to Objective-C property name
            // Protocol property uses objcPropertyName, alias provides swiftPropertyName
            let objcPropertyName = swiftPropertyName(property.name)  // e.g., "passwordProtected"
            let swiftPropertyName = escapeReservedKeyword(cocoaKey)  // e.g., "isPasswordProtected"

            // Skip if they're the same (no alias needed)
            guard objcPropertyName != swiftPropertyName else { continue }

            // Check if the alias name would conflict with existing protocol properties
            // by looking for properties with the same name across all classes
            let aliasNameConflicts = model.suites.flatMap { $0.classes }.contains { otherClass in
                otherClass.properties.contains { otherProperty in
                    self.swiftPropertyName(otherProperty.name) == swiftPropertyName
                }
            }

            // Skip generating the alias if it would conflict with a protocol property
            if aliasNameConflicts {
                if verbose {
                    print("Skipping alias '\(swiftPropertyName)' for '\(objcPropertyName)' in \(sdefClass.name) to avoid protocol property conflict")
                }
                continue
            }

            // For property aliases in extensions, we need to use the correct type references
            let baseTypeName = swiftNamespacedTypeName(property.type.baseType)

            // Only prefix with namespace for class types, not basic types
            var swiftType: String
            let basicTypes = ["String", "Int", "Double", "Bool", "Date", "URL", "[String: Any]", "Any", "NSNull", "NSRect", "NSNumber", "NSPoint", "NSSize", "SBObject"]
            if basicTypes.contains(baseTypeName) {
                swiftType = baseTypeName
            } else {
                swiftType = "\(baseName).\(baseTypeName)"
            }

            // Skip list properties - they already have strongly typed accessors generated elsewhere
            // that provide the Swift idiomatic names
            if property.type.isList {
                continue
            } else {
                // Generate getter/setter to match the exact protocol property type
                // The protocol property defines the expected return type, alias should match exactly
                let protocolPropertyType = swiftNamespacedType(for: property.type)

                // For non-optional protocol types, provide sensible defaults if underlying property might be nil
                if !protocolPropertyType.hasSuffix("?") {
                    let defaultValue = switch swiftType {
                    case "String":
                        "\(objcPropertyName) ?? \"\""
                    case "Int":
                        "\(objcPropertyName) ?? 0"
                    case "Double":
                        "\(objcPropertyName) ?? 0.0"
                    case "Bool":
                        "\(objcPropertyName) ?? false"
                    case "URL":
                        "\(objcPropertyName) ?? URL(fileURLWithPath: \"\")"
                    case "Date":
                        "\(objcPropertyName) ?? Date()"
                    case "NSNumber":
                        "\(objcPropertyName) ?? NSNumber(value: 0)"
                    default:
                        // For enum and complex types, check if we can provide a reasonable default
                        if swiftType.contains(".") {
                            // For complex types, use implicitly unwrapped optional to avoid crashes
                            // This allows users to check for nil if needed while maintaining type compatibility
                            objcPropertyName
                        } else {
                            "\(objcPropertyName) ?? \(swiftType)()"
                        }
                    }

                    // For complex types that could be nil, use implicitly unwrapped optional return type
                    let returnType = if swiftType.contains(".") && defaultValue == objcPropertyName {
                        "\(swiftType)!"
                    } else {
                        swiftType
                    }

                    code += """

                        /// Swift idiomatic alias for \(objcPropertyName)
                        var \(swiftPropertyName): \(returnType) { \(defaultValue) }
                    """
                } else {
                    // Protocol type is optional, alias can be optional too
                    code += """

                        /// Swift idiomatic alias for \(objcPropertyName)
                        var \(swiftPropertyName): \(swiftType) { \(objcPropertyName) }
                    """
                }
            }
        }

        return code
    }

    private func swiftCaseName(_ name: String) -> String {
        let cleaned = name
            .replacingOccurrences(of: " ", with: "")
            .replacingOccurrences(of: "-", with: "")
            .replacingOccurrences(of: "_", with: "")

        return cleaned.lowercaseFirstLetter()
    }

    private func formatEnumeratorCode(_ code: String) -> String {
        // Convert 4-character codes to proper format
        if code.count == 4 {
            let chars = Array(code)
            let formatted = chars.compactMap { char in
                guard let ascii = char.asciiValue else { return "00" }
                return String(format: "%02x", ascii)
            }.joined()
            return "0x\(formatted)"
        }
        // Handle other code formats
        if code.hasPrefix("0x") || code.allSatisfy({ $0.isHexDigit }) {
            return code.hasPrefix("0x") ? code : "0x\(code)"
        }
        return "'\(code)'"
    }

    /// Generates a public enum containing all scripting class names from the SDEF.
    ///
    /// This method creates a CaseIterable, RawRepresentable enum that encompasses all
    /// scripting class names found in the SDEF file, including both regular classes
    /// and class extensions. The enum cases are generated using a transformation
    /// similar to the Python reference implementation, converting class names to
    /// proper Swift enum case names.
    ///
    /// - Returns: Swift code for the class names enumeration
    // MARK: - Namespace Methods

    private func generateNamespacedStandardEnums() -> String {
        // Check if we already have a SaveOptions or similar enum in the SDEF
        let hasExistingSaveOptions = model.suites.contains { suite in
            suite.enumerations.contains { enumeration in
                let enumName = swiftClassName(enumeration.name)
                return enumName.lowercased().contains("saveoptions") ||
                       enumName.lowercased() == "savo" ||
                       enumeration.name.lowercased().contains("save options")
            }
        }

        if hasExistingSaveOptions {
            // Don't generate the standard SaveOptions if one already exists
            return ""
        }

        return """

            // MARK: - Save Options

            /// Standard save options for dialogs
            @objc public enum SaveOptions: AEKeyword {
                case yes = 0x79657320  // 'yes '
                case no = 0x6e6f2020   // 'no  '
                case ask = 0x61736b20  // 'ask '
            }

        """
    }

    private func generateNamespacedTypeAliases() -> String {
        var aliases = """

            // MARK: - Type Aliases

        """

        // Don't generate Application typealias when application protocol exists
        // The application protocol is generated from CocoaStandard.sdef for most applications
        // Creating both a typealias and protocol with the same name causes naming conflicts

        aliases += """
            public typealias Object = SBObject
            public typealias ElementArray = SBElementArray

            // MARK: - Common Value Types
            /// Represents an RGB color value
            public typealias RGBColor = NSColor
            /// Represents a TIFF picture
            public typealias TIFFPicture = NSImage

        """
        return aliases
    }

    private func generateNamespacedClassNamesEnum() -> String {
        var code = """

            // MARK: - Scripting Class Names

            /// An enumeration of all scripting class names defined in the SDEF.
            ///
            /// These string constants can be used when working with the Scripting Bridge
            /// to reference specific scriptable classes by name.
            public enum ClassNames {
        """

        // Collect all class names
        var classNames: Set<String> = []

        // Add standard classes
        for standardClass in model.standardClasses {
            classNames.insert(standardClass.name)
        }

        // Add regular classes
        for suite in model.suites {
            for sdefClass in suite.classes {
                classNames.insert(sdefClass.name)
            }
        }

        // Sort for consistent output
        let sortedNames = classNames.sorted()

        for className in sortedNames {
            let caseName = swiftPropertyName(className).replacingOccurrences(of: " ", with: "")
            let escapedName = escapeReservedKeyword(caseName)
            code += "\n        public static let \(escapedName) = \"\(className)\""
        }

        code += "\n    }\n"
        return code
    }

    private func generateNamespacedEnumeration(_ enumeration: SDEFEnumeration) -> String {
        let enumName = swiftClassName(enumeration.name)

        var code = """

            // MARK: - \(enumeration.name)

        """

        if let description = enumeration.description {
            code += "    /// \(description.capitalizingFirstLetter())\n"
        }

        code += "    @objc public enum \(enumName): AEKeyword, Sendable {\n"

        // Track used raw values and their corresponding case names
        var usedRawValues: [String: String] = [:]
        var aliasProperties: [String] = []

        for enumerator in enumeration.enumerators {
            if let description = enumerator.description {
                code += "        /// \(description.capitalizingFirstLetter())\n"
            }

            let caseName = swiftCaseName(enumerator.name)
            let codeValue = formatEnumeratorCode(enumerator.code)

            // Check if we've already used this raw value
            if let existingCaseName = usedRawValues[codeValue] {
                // Create an alias property instead of a duplicate case
                if verbose {
                    print("Creating alias \(caseName) -> \(existingCaseName) for duplicate raw value \(codeValue) in \(enumName)")
                }
                aliasProperties.append("        /// Alias for \(existingCaseName)")
                aliasProperties.append("        public static let \(caseName): \(enumName) = .\(existingCaseName)")
            } else {
                // This is a new raw value, create the actual case
                usedRawValues[codeValue] = caseName
                code += "        case \(caseName) = \(codeValue)\n"
            }
        }

        // Add alias properties after the cases
        if !aliasProperties.isEmpty {
            code += "\n        // MARK: - Aliases for duplicate raw values\n"
            for aliasProperty in aliasProperties {
                code += "\(aliasProperty)\n"
            }
        }

        code += "    }\n"

        return code
    }

    private func generatePrefixedTypealiasesSection() -> String {
        var code = """

        // MARK: - Prefixed Type Aliases (for backward compatibility)

        """

        // Check if the SDEF model defines an Application class
        let hasApplicationClass = model.suites.contains { suite in
            suite.classes.contains { sdefClass in
                sdefClass.name.lowercased() == "application"
            }
        }

        if !hasApplicationClass {
            code += "public typealias \(baseName)Application = \(baseName).Application\n"
        }

        code += """
        public typealias \(baseName)Object = \(baseName).Object
        public typealias \(baseName)ElementArray = \(baseName).ElementArray

        """

        // Check if we should generate SaveOptions typealias
        let hasExistingSaveOptions = model.suites.contains { suite in
            suite.enumerations.contains { enumeration in
                let enumName = swiftClassName(enumeration.name)
                return enumName.lowercased().contains("saveoptions") ||
                       enumName.lowercased() == "savo" ||
                       enumeration.name.lowercased().contains("save options")
            }
        }

        if !hasExistingSaveOptions {
            code += "public typealias \(baseName)SaveOptions = \(baseName).SaveOptions\n"
        }

        code += "\n"

        // Enumerations - avoid duplicates
        var generatedTypealiases = Set<String>()
        for suite in model.suites {
            for enumeration in suite.enumerations {
                let enumName = swiftClassName(enumeration.name)
                let typealiasName = "\(baseName)\(enumName)"
                if !generatedTypealiases.contains(typealiasName) {
                    code += "public typealias \(typealiasName) = \(baseName).\(enumName)\n"
                    generatedTypealiases.insert(typealiasName)
                }
            }
        }

        return code + "\n"
    }

    private func generateFlatTypealiasesSection() -> String {
        var code = """

        // MARK: - Flat Type Aliases (for use as a separate module)

        """

        // Check if the SDEF model defines an Application class
        let hasApplicationClass = model.suites.contains { suite in
            suite.classes.contains { sdefClass in
                sdefClass.name.lowercased() == "application"
            }
        }

        if !hasApplicationClass {
            code += "public typealias Application = \(baseName).Application\n"
        }

        code += """
        public typealias Object = \(baseName).Object
        public typealias ElementArray = \(baseName).ElementArray

        """

        // Check if we should generate SaveOptions typealias
        let hasExistingSaveOptions = model.suites.contains { suite in
            suite.enumerations.contains { enumeration in
                let enumName = swiftClassName(enumeration.name)
                return enumName.lowercased().contains("saveoptions") ||
                       enumName.lowercased() == "savo" ||
                       enumeration.name.lowercased().contains("save options")
            }
        }

        if !hasExistingSaveOptions {
            code += "public typealias SaveOptions = \(baseName).SaveOptions\n"
        }

        code += "\n"

        // Enumerations - avoid duplicates
        var generatedTypealiases = Set<String>()
        for suite in model.suites {
            for enumeration in suite.enumerations {
                let enumName = swiftClassName(enumeration.name)
                if !generatedTypealiases.contains(enumName) {
                    code += "public typealias \(enumName) = \(baseName).\(enumName)\n"
                    generatedTypealiases.insert(enumName)
                }
            }
        }

        return code + "\n"
    }

    private func generateClassNamesEnum() -> String {
        var classNames = Set<String>()

        // Collect all class names (parser already filtered hidden classes if needed)
        for suite in model.suites {
            for sdefClass in suite.classes {
                classNames.insert(sdefClass.name)
            }

            // Also collect class extension names
            for classExtension in suite.classExtensions {
                classNames.insert(classExtension.extends)
            }
        }

        // Sort names for consistent output
        let sortedNames = classNames.sorted()

        var code = """

        /// An enumeration of all scripting class names available in this application.
        ///
        /// This enum provides a type-safe way to reference all scriptable classes defined
        /// in the application's scripting dictionary. Each case corresponds to a class
        /// that can be accessed through the Scripting Bridge framework.
        public enum \(baseName)ScriptingClassNames: String, CaseIterable {

        """

        for name in sortedNames {
            let caseName = transformToEnumCase(name)
            code += "    case \(caseName) = \"\(name)\"\n"
        }

        code += "}\n\n"

        return code
    }

    /// Transforms a class name into a proper Swift enum case name.
    ///
    /// This method implements the same transformation logic as the Python reference,
    /// converting class names by removing quotes and hyphens, capitalizing words,
    /// and then converting to camelCase for the enum case.
    ///
    /// - Parameter name: The original class name from the SDEF
    /// - Returns: A properly formatted Swift enum case name
    private func transformToEnumCase(_ name: String) -> String {
        // Remove quotes and replace hyphens with spaces
        let transformed = name
            .replacingOccurrences(of: "\"", with: "")
            .replacingOccurrences(of: "-", with: " ")

        // Capitalize each word and remove spaces
        let words = transformed.components(separatedBy: " ")
        let capitalized = words.map { $0.capitalizingFirstLetter() }.joined()

        // Convert to camelCase (first letter lowercase)
        return capitalized.lowercaseFirstLetter()
    }
}

/// Errors that can occur during Swift code generation.
///
/// These errors indicate problems encountered while transforming SDEF model data
/// into Swift source code, such as unsupported type definitions or invalid
/// naming conventions that cannot be mapped to valid Swift identifiers.
public enum SDEFCodeGenerationError: Error {
    /// An unsupported SDEF type was encountered that cannot be mapped to Swift
    case unsupportedType(String)

    /// An invalid identifier name was found that cannot be converted to valid Swift
    case invalidIdentifier(String)

    /// A structural problem in the SDEF model prevents code generation
    case invalidModel(String)
}

extension SDEFCodeGenerationError: LocalizedError {
    /// A localised description of the code generation error.
    ///
    /// Provides detailed error messages that explain what went wrong during the
    /// Swift code generation process. These messages are designed to help developers
    /// understand and resolve issues with their SDEF files or generation configuration.
    ///
    /// - Returns: A descriptive error message suitable for display or logging
    public var errorDescription: String? {
        switch self {
        case .unsupportedType(let type):
            return "Unsupported SDEF type: \(type)"
        case .invalidIdentifier(let identifier):
            return "Invalid Swift identifier: \(identifier)"
        case .invalidModel(let message):
            return "Invalid SDEF model: \(message)"
        }
    }
}

// MARK: - String Extensions

extension String {
    /// Returns a copy of the string with the first character capitalised.
    ///
    /// This method converts the first character of the string to uppercase while
    /// leaving the rest of the string unchanged. It's commonly used for converting
    /// identifiers to proper Swift type names and method names.
    ///
    /// - Returns: A string with the first character capitalised
    func capitalizingFirstLetter() -> String {
        return prefix(1).uppercased() + dropFirst()
    }

    /// Returns a copy of the string with the first character in lowercase.
    ///
    /// This method converts the first character of the string to lowercase while
    /// preserving the case of all other characters. It's used for generating
    /// proper Swift property and variable names from SDEF identifiers.
    ///
    /// - Returns: A string with the first character in lowercase
    func lowercaseFirstLetter() -> String {
        return prefix(1).lowercased() + dropFirst()
    }
}
