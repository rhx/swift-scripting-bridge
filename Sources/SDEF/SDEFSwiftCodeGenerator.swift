//
// SDEFSwiftCodeGenerator.swift
// SDEF
//
// Created by Rene Hexel on 1/06/2024.
// Copyright Â© 2024, 2025 Rene Hexel. All rights reserved.
//
import Foundation
import SwiftSyntax
import SwiftSyntaxBuilder

/// A code generator that produces Swift Scripting Bridge code from parsed SDEF models.
///
/// The `SDEFSwiftCodeGenerator` transforms structured SDEF data into clean, type-safe Swift code
/// that provides interfaces for controlling scriptable macOS applications through the Scripting
/// Bridge framework. The generator handles proper Swift naming conventions, type mapping, and
/// protocol generation to create idiomatic Swift code from Apple Event definitions.
///
/// The generated code includes protocols for each scriptable class, enumerations for constant
/// values, type aliases for common Scripting Bridge types, and extension methods that provide
/// a complete Swift interface to the application's scripting capabilities.
public final class SDEFSwiftCodeGenerator {
    private let model: SDEFModel
    private let baseName: String
    private let verbose: Bool

    /// Creates a new Swift code generator with the specified configuration.
    ///
    /// The generator uses the provided SDEF model to create comprehensive Swift code that
    /// mirrors the application's scripting interface. The basename parameter determines
    /// the prefix used for all generated types, ensuring they don't conflict with other
    /// generated code in the same project.
    ///
    /// - Parameters:
    ///   - model: The parsed SDEF model containing all scripting definitions
    ///   - basename: The prefix to use for all generated Swift types
    ///   - verbose: Whether to enable detailed logging during code generation
    public init(model: SDEFModel, basename: String, verbose: Bool) {
        self.model = model
        self.baseName = basename
        self.verbose = verbose
    }

    /// Generates complete Swift source code from the SDEF model.
    ///
    /// This method produces a complete Swift source file that includes all necessary imports,
    /// type definitions, protocols, and extensions needed to interact with the scriptable
    /// application. The generated code follows Swift best practices and provides type-safe
    /// interfaces that mirror the application's Apple Event scripting capabilities.
    ///
    /// The generation process creates several components: standard protocol definitions for
    /// generic scripting methods, enumerations for constant values, protocols for each
    /// scriptable class with their properties and methods, and extensions that conform
    /// Scripting Bridge types to these protocols.
    ///
    /// - Returns: A complete Swift source code string ready to be written to a file
    /// - Throws: `SDEFCodeGenerationError` if the model contains invalid or unsupported definitions
    public func generateCode() throws -> String {
        var code = """
        //
        // \(baseName).swift
        // Generated by sdef2swift
        //

        import Foundation
        import ScriptingBridge

        """

        // Generate type aliases for common ScriptingBridge types
        code += generateTypeAliases()

        // Generate standard protocols and enums first
        code += generateApplicationProtocol()

        // Generate enumerations
        for suite in model.suites {
            for enumeration in suite.enumerations {
                code += generateEnumeration(enumeration)
            }
        }

        // Generate protocols for classes
        for suite in model.suites {
            for sdefClass in suite.classes {
                code += generateClassProtocol(sdefClass, suite: suite)
            }

            // Generate protocols for class extensions
            for classExtension in suite.classExtensions {
                code += generateClassExtensionProtocol(classExtension, suite: suite)
            }
        }

        // Generate SBApplication extension
        code += generateSBApplicationExtension()

        return code
    }

    private func generateTypeAliases() -> String {
        return """

        // MARK: - Type Aliases

        public typealias \(baseName)Application = SBApplication
        public typealias \(baseName)Object = SBObject
        public typealias \(baseName)ElementArray = SBElementArray

        """
    }

    private func generateEnumeration(_ enumeration: SDEFEnumeration) -> String {
        let enumName = "\(baseName)\(enumeration.name.capitalizingFirstLetter().replacingOccurrences(of: " ", with: "").replacingOccurrences(of: "-", with: ""))"

        var code = """

        // MARK: - \(enumeration.name)

        """

        if let description = enumeration.description {
            code += "/// \(description)\n"
        }

        code += "@objc public enum \(enumName): AEKeyword {\n"

        for enumerator in enumeration.enumerators {
            if let description = enumerator.description {
                code += "    /// \(description)\n"
            }

            let caseName = swiftCaseName(enumerator.name)
            let codeValue = formatEnumeratorCode(enumerator.code)
            code += "    case \(caseName) = \(codeValue)\n"
        }

        code += "}\n"

        return code
    }

    private func generateClassProtocol(_ sdefClass: SDEFClass, suite: SDEFSuite) -> String {
        let protocolName = "\(baseName)\(sdefClass.name.capitalizingFirstLetter().replacingOccurrences(of: " ", with: ""))"

        var code = """

        // MARK: - \(sdefClass.name)

        """

        if let description = sdefClass.description {
            code += "/// \(description)\n"
        }

        var inheritanceList = ["SBObjectProtocol"]

        // Add GenericMethods for standard classes
        if ["window", "document", "application"].contains(sdefClass.name.lowercased()) {
            inheritanceList.append("\(baseName)GenericMethods")
        }

        if let inherits = sdefClass.inherits {
            let cleanInherits = inherits.capitalizingFirstLetter().replacingOccurrences(of: " ", with: "")
            inheritanceList.append("\(baseName)\(cleanInherits)")
        }

        code += "@objc public protocol \(protocolName): \(inheritanceList.joined(separator: ", ")) {\n"

        // Generate properties
        for property in sdefClass.properties {
            code += generateProperty(property)
        }

        // Generate id() method for classes that have it
        if sdefClass.properties.contains(where: { $0.name == "id" }) {
            code += "    @objc optional func id() -> Int\n"
        }

        // Generate element arrays
        for element in sdefClass.elements {
            let methodName = element.type.lowercased() + "s"
            code += "    @objc optional func \(methodName)() -> SBElementArray\n"
        }

        // Generate setter methods for writable properties
        for property in sdefClass.properties {
            if property.access != "r" { // Not read-only
                let propertyName = swiftPropertyName(property.name)
                let swiftType = swiftType(for: property.type)

                // Fix setter naming for special cases
                let setterName = switch property.name.lowercased() {
                case "current tab":
                    "CurrentTab"
                case "url":
                    "URL"
                default:
                    property.name.capitalizingFirstLetter().replacingOccurrences(of: " ", with: "")
                }

                code += "    @objc optional func set\(setterName)(_ \(propertyName): \(swiftType))\n"
            }
        }

        code += "}\n"

        // Generate SBObject extension
        code += """

        extension SBObject: \(protocolName) {}

        """

        return code
    }

    private func generateClassExtensionProtocol(_ classExtension: SDEFClassExtension, suite: SDEFSuite) -> String {
        let baseTypeName = classExtension.extends.capitalizingFirstLetter().replacingOccurrences(of: " ", with: "")
        let protocolName = "\(baseName)\(baseTypeName)"

        var code = """

        // MARK: - \(classExtension.extends) Extension

        @objc public protocol \(protocolName): SBObject {

        """

        // Generate properties
        for property in classExtension.properties {
            code += generateProperty(property)
        }

        // Generate element arrays
        for element in classExtension.elements {
            let methodName = element.type.lowercased() + "s"
            code += "    @objc optional func \(methodName)() -> SBElementArray\n"
        }

        code += "}\n"

        // Generate SBObject extension
        code += """

        extension SBObject: \(protocolName) {}

        """

        return code
    }

    private func generateProperty(_ property: SDEFProperty) -> String {
        var code = ""

        if let description = property.description {
            code += "    /// \(description)\n"
        }

        let propertyName = swiftPropertyName(property.name)
        let swiftType = swiftType(for: property.type)

        // Special handling for id property - make it a method
        if property.name == "id" {
            return "" // Skip generating property for id, it will be handled as a method
        }

        let readOnly = property.access == "r" ? " { get }" : " { get set }"

        code += "    @objc optional var \(propertyName): \(swiftType)\(readOnly)\n"

        return code
    }

    private func generateApplicationProtocol() -> String {
        return """

        // MARK: - Save Options Enum

        @objc public enum \(baseName)SaveOptions: AEKeyword {
            case yes = 0x79657320  // 'yes '
            case no = 0x6e6f2020   // 'no  '
            case ask = 0x61736b20  // 'ask '
        }

        // MARK: - Generic Methods Protocol

        @objc public protocol \(baseName)GenericMethods {
            @objc optional func closeSaving(_ saving: \(baseName)SaveOptions, savingIn: URL?)
            @objc optional func saveIn(_ in_: URL?, as: Any?)
            @objc optional func printWithProperties(_ withProperties: [String: Any]?, printDialog: Bool)
            @objc optional func delete()
            @objc optional func duplicateTo(_ to: SBObject?, withProperties: [String: Any]?)
            @objc optional func moveTo(_ to: SBObject?)
        }

        // MARK: - Application Protocol

        @objc public protocol \(baseName)ApplicationProtocol: SBApplicationProtocol {
            @objc optional func documents() -> SBElementArray
            @objc optional func windows() -> SBElementArray
        }

        """
    }

    private func generateSBApplicationExtension() -> String {
        return """
        extension SBApplication: \(baseName)ApplicationProtocol {}

        extension SBObject: \(baseName)GenericMethods {}

        """
    }

    // MARK: - Helper Methods

    private func swiftType(for propertyType: SDEFPropertyType) -> String {
        var baseType = swiftTypeName(propertyType.baseType)

        if propertyType.isList {
            baseType = "[\(baseType)]"
        }

        if propertyType.isOptional {
            baseType += "?"
        }

        return baseType
    }

    private func swiftTypeName(_ objcType: String) -> String {
        switch objcType.lowercased() {
        case "text", "string":
            return "String"
        case "integer", "int":
            return "Int"
        case "real", "double":
            return "Double"
        case "boolean", "bool":
            return "Bool"
        case "date":
            return "Date"
        case "file", "alias":
            return "URL"
        case "record":
            return "[String: Any]"
        case "any":
            return "Any"
        case "missing value":
            return "NSNull"
        case "rectangle":
            return "NSRect"
        case "number":
            return "NSNumber"
        case "point":
            return "NSPoint"
        case "size":
            return "NSSize"
        default:
            // Assume it's a class name - clean up the name
            let cleanType = objcType
                .capitalizingFirstLetter()
                .replacingOccurrences(of: " ", with: "")
                .replacingOccurrences(of: "-", with: "")
            return "\(baseName)\(cleanType)"
        }
    }

    private func swiftPropertyName(_ name: String) -> String {
        let sanitised = name
            .replacingOccurrences(of: " ", with: "")
            .replacingOccurrences(of: "-", with: "")
            .replacingOccurrences(of: "_", with: "")

        // Handle special cases for better naming
        let properName = sanitised.lowercaseFirstLetter()

        // Fix common naming issues
        switch properName {
        case "currenttab":
            return "currentTab"
        case "url", "uRL":
            return "url"
        default:
            return properName
        }
    }

    private func swiftCaseName(_ name: String) -> String {
        let cleaned = name
            .replacingOccurrences(of: " ", with: "")
            .replacingOccurrences(of: "-", with: "")
            .replacingOccurrences(of: "_", with: "")

        return cleaned.lowercaseFirstLetter()
    }

    private func formatEnumeratorCode(_ code: String) -> String {
        // Convert 4-character codes to proper format
        if code.count == 4 {
            let chars = Array(code)
            let formatted = chars.compactMap { char in
                guard let ascii = char.asciiValue else { return "00" }
                return String(format: "%02x", ascii)
            }.joined()
            return "0x\(formatted)"
        }
        // Handle other code formats
        if code.hasPrefix("0x") || code.allSatisfy({ $0.isHexDigit }) {
            return code.hasPrefix("0x") ? code : "0x\(code)"
        }
        return "'\(code)'"
    }
}

/// Errors that can occur during Swift code generation.
///
/// These errors indicate problems encountered while transforming SDEF model data
/// into Swift source code, such as unsupported type definitions or invalid
/// naming conventions that cannot be mapped to valid Swift identifiers.
public enum SDEFCodeGenerationError: Error {
    /// An unsupported SDEF type was encountered that cannot be mapped to Swift
    case unsupportedType(String)

    /// An invalid identifier name was found that cannot be converted to valid Swift
    case invalidIdentifier(String)

    /// A structural problem in the SDEF model prevents code generation
    case invalidModel(String)
}

extension SDEFCodeGenerationError: LocalizedError {
    /// A localised description of the code generation error.
    ///
    /// Provides detailed error messages that explain what went wrong during the
    /// Swift code generation process. These messages are designed to help developers
    /// understand and resolve issues with their SDEF files or generation configuration.
    ///
    /// - Returns: A descriptive error message suitable for display or logging
    public var errorDescription: String? {
        switch self {
        case .unsupportedType(let type):
            return "Unsupported SDEF type: \(type)"
        case .invalidIdentifier(let identifier):
            return "Invalid Swift identifier: \(identifier)"
        case .invalidModel(let message):
            return "Invalid SDEF model: \(message)"
        }
    }
}

// MARK: - String Extensions

extension String {
    /// Returns a copy of the string with the first character capitalised.
    ///
    /// This method converts the first character of the string to uppercase while
    /// leaving the rest of the string unchanged. It's commonly used for converting
    /// identifiers to proper Swift type names and method names.
    ///
    /// - Returns: A string with the first character capitalised
    func capitalizingFirstLetter() -> String {
        return prefix(1).uppercased() + dropFirst()
    }

    /// Returns a copy of the string with the first character in lowercase.
    ///
    /// This method converts the first character of the string to lowercase while
    /// preserving the case of all other characters. It's used for generating
    /// proper Swift property and variable names from SDEF identifiers.
    ///
    /// - Returns: A string with the first character in lowercase
    func lowercaseFirstLetter() -> String {
        return prefix(1).lowercased() + dropFirst()
    }
}
